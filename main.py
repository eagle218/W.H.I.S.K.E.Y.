# -*- coding: utf-8 -*-
"""
This app provides functionality to help students using Telegram Messenger

For the correct processing of data, the DB SQLITE is used, 
    data is entered  and extracted there.

Functionality provided by this program includes:
    - Schedule operations:
        - /schedule: Get the schedule for the current day.
        - /schedule_day [day]: Get the schedule for a specific day of the week.
        - /new_schedule [day] [subject] [time]: Add a new schedule entry for a specific day, subject, and time.

    - Group operations:
        - /my_group: Get the name of your current group.

    - Document operations:
        - /doc [topic] [group] [your_name] [instructor_name]: Create a document with the specified topic, group, your name, and instructor name.
        - /specialDoc  [topic name] -> return .docx file with data, generated by OpenAi ChatGpt, approximate waiting time - 20 seconds.

    - Foreign words operation:
        - /word [Text]: Identify the source language and translate it into Ukrainian. Then add it to the database.
        - /uword [Language to translate] [text in Ukrainian]: Translate the text from Ukrainian to the specified language. Then add it to the database.
        - /word_list: Provide a list of all words that the user has written.
        - /certain_words [Language]: Provide a list of words in the specified language.
        - /word_done [Language], [index]: Mark a word in the specified language and with the given index as completed.
        - /remove_words [Language]: Remove all words in the specified language.

    - Task operations:
        - /new_task [task_description]: Add a new task to your task list.
        - /task_list: Get information about your tasks.
        - /task_done [task_number]: Mark a task as completed.
        - /dell_task [task_number]: Delete a task from your task list.

    - HomeWork Operations:
        - /homeWorkAdd [subject name], [homework:str]: Add user homework to Database
        - /homeWorkInfo [subject name] - get data about user tasks
        - /homeWorkMainInfo - displays all your homework.
        - /homeWorkDell [the name of the item where you want to delete the data]: Delete user homework from certain subject (based on query)
                                                                              
    - AI operations:
        - /iso [query]: Makes a request to the OpenAi server to get a response from the neural network ChatGpt
        - /api [api-key]: accepts from the user OpenAi api-key
        - /new_api [new api-key]  update user OpenAi key in database
        - /generate_image [query]: Generate an image based on the specified query.
        - /remove_background: After this command, send photo, and program return one without background.
        - /uk_ocr - Get text on ukraine or russian language from image
        - /ocr - Get text on  English, deutsch, french language from image

    - Miscellaneous operations:
        - /resources [query]: get links of sites, related to query.
        - /info: Get the latest news information.
        - /weather [city]: Get the weather information for the specified city.
        - Audio file translation: The bot can automatically translate audio files from Ukrainian and russian languages.
"""





""" Standard library imports """
import io
import os
import re
import time
import datetime
import tempfile
import threading
import subprocess
from re import escape

""" Third-party library imports """
import json
import vosk
import wave
import html
import openai
import asyncio
import logging
import requests
import schedule
from fuzzywuzzy import process
from pydub import AudioSegment
from datetime import datetime, timedelta

""" AIogram library imports """
from aiogram import Bot, types
from aiogram.utils import executor
from aiogram.utils import exceptions
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher import Dispatcher
from aiogram.types import Message, ParseMode
from aiogram.utils.exceptions import BadRequest
from aiogram.types import ContentType, InputFile
from aiogram.dispatcher import FSMContext, filters
from aiogram.dispatcher.filters import BoundFilter
from aiogram.dispatcher.filters import Command, BoundFilter
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup


""" Local imports """
import config
import bot_utils
from stt import STT
from pathlib import Path
from students_database import Student, OpenAiChatHistory, ScheduleTable, HomeworkBot, WordDatabase


"""                                           """
"""    Student Database initialization        """
"""                                           """
student = Student()
scheduleTable = ScheduleTable()
homeworkData  = HomeworkBot()
wordDataBase  = WordDatabase()
"""                                           """
"""    Telegram Bot initialization            """
"""                                           """

bot = Bot(token=config.TOKEN, parse_mode=types.ParseMode.HTML)
dp = Dispatcher(bot, storage=MemoryStorage())
# Setting up logging
logging.basicConfig(level=logging.INFO)




"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """

"""                                                                    """
"""                                                                    """
"""                TELEGRAM BOT COMMANDS PROCESSING                    """
"""                                                                    """
"""                                                                    """

"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """





"""                                                                     """
"""     –°alculate which command need user data of university group      """
"""                                                                     """
command_groups = {
    "/help": False, 
    "/new_schedule": True, 
    "/schedule": False,
    "/schedule_day": True,
    
    "/my_group": False,
     

    "/doc": False,
    "/specialDoc": False,

    "/word": False,
    "/word_list": False,
    "/list_word": False,
    "/certain_words": False,
    "/word_done": False,
    "/remove_words": False,

    "/new_task": False, 
    "/task_list": False,
    "/task_done": False,
    "/dell_task": False,

    "/homeWorkAdd": False,
    "/homeWorkInfo": False,
    "/homeWorkDell": False,
    "/homeWorkMainInfo": False,

    "/iso":False,  
    "/api": False, 
    "/new_api":False, #

    "/generate_image": False, 
    "/remove_background": False, 
    "/uk_ocr": False,
    "/ocr": False,

    "/resources": False, 
    "/info": False,
    "/weather":False, 
    "/chat_id": False
}


@dp.message_handler(commands=['start'])
async def send_greeting(message: types.Message, state: FSMContext):
    if message.chat.type == types.ChatType.PRIVATE:
        # If the bot is running in a private chat with the user
       
        await message.answer(f'–ü—Ä–∏–≤—ñ—Ç, {message.from_user.first_name}!\n–Ø - –±–æ—Ç –¥–ª—è –¥–æ–ø–æ–º–æ–≥–∏ —Å—Ç—É–¥–µ–Ω—Ç–∞–º. –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–æ–º–∞–Ω–¥:\n')
        await asyncio.sleep(1)
        await handle_info_command_help(message)
    else:
        # If the bot is running in a channel or group
        await message.answer('–ü—Ä–∏–≤–µ—Ç, —É—Å—ñ–º!\n–Ø - –±–æ—Ç –¥–ª—è –¥–æ–ø–æ–º–æ–≥–∏ —Å—Ç—É–¥–µ–Ω—Ç–∞–º. –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–æ–º–∞–Ω–¥:\n')
        await asyncio.sleep(1)
        await handle_info_command_help(message)




"""                                           """
"""            Info about commands            """
"""                                           """

@dp.message_handler(commands=['help'])
async def handle_info_command_help(message: types.Message):
    """
    This function handles the '/help' command. It provides information about the available commands and their usage.

    Args:
        message: The message object containing the user's input.

    Returns:
        None
    """
    user_id = message.from_user.id
 
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)

    await bot.send_message(message.chat.id, f"<b>Commands:</b>\n\n"
                                            "<b>–†–æ–∑–∫–ª–∞–¥</b>:\n"
                                            "/schedule - —Ä–æ–∑–∫–ª–∞–¥ –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ—à–Ω—ñ–π –¥–µ–Ω—å\n"
                                            "/schedule_day [–¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ]\n"
                                            "/new_schedule [–¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ], [–Ω–∞–∑–≤–∞ –ø—Ä–µ–¥–º–µ—Ç–∞], [—á–∞—Å —É —Ñ–æ—Ä–º–∞—Ç—ñ –≥–æ–¥–∏–Ω–∞:—Ö–≤–∏–ª–∏–Ω–∞ (16:30)]\n"
                                            "/my_group [–Ω–∞–∑–≤–∞ –≤–∞—à–æ—ó –≥—Ä—É–ø–∏]\n\n"
                                            
                                            "<b>Docx —Ñ–∞–π–ª–∏:</b>"
                                            "\n   /doc [–Ω–∞–∑–≤–∞ —Ç–µ–º–∏], [–≥—Ä—É–ø–∏], [–≤–∞—à–µ —ñ–º'—è], [—ñ–º'—è –í–∏–∫–ª–∞–¥–∞—á–∞]\n"
                                            "   /specialDoc [–Ω–∞–∑–≤–∞ —Ç–µ–º–∏]\n\n"

                                            "<b>–°–ª–æ–≤–Ω–∏–∫:</b>"
                                            "\n   /word - –ü–µ—Ä–µ–≤–æ–¥–∏—Ç—å —Ç–µ–∫—Å—Ç —Ç–∞ –¥–æ–±–∞–≤–ª—è—î –π–æ–≥–æ —É –≤–∞—à —Å–ª–æ–≤–Ω–∏–∫\n"
                                            "   /uword - –ü–µ—Ä–µ–≤–æ–¥–∏—Ç—å —Ç–µ–∫—Å—Ç –∑ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—ó –Ω–∞ –º–æ–≤—É, —è–∫—É –≤–∏ –≤–∫–∞–∑–∞–ª–∏, —Ç–∞ –¥–æ–±–∞–≤–ª—è—î –π–æ–≥–æ —É –≤–∞—à —Å–ª–æ–≤–Ω–∏–∫\n"
                                            "   /word_list - –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –≤–∞—à–∏—Ö —Å–ª—ñ–≤\n"
                                            "   /certain_words - –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ —Å–ª—ñ–≤ –Ω–∞ —É–∫–∞–∑–∞–Ω—ñ–π –º–æ–≤—ñ —ñ–∑ –≤–∞—à–æ–≥–æ —Å–ª–æ–≤–Ω–∏–∫–∞\n"
                                            "   /remove_words - –í–∏–¥–∞–ª—è—î —Å–ª–æ–≤–æ\n\n"

                                            "<b>–ó–∞–≤–¥–∞–Ω–Ω—è:</b>"
                                            "\n   /new_task [–Ω–∞–∑–≤–∞ –≤–∞—à–æ–≥–æ —Ç–∞—Å–∫—É]\n"
                                            "   /task_list - –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–∞–Ω—ñ –ø—Ä–æ –≤–∞—à—ñ —Ç–∞—Å–∫–∏\n"
                                            "   /task_done [–Ω–æ–º–µ—Ä —Ç–∞—Å–∫—É] - –≤—ñ–¥–º—ñ—á–∞—î —Ç–∞—Å–∫ —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–∏–π\n"
                                            "   /dell_task - –≤–∏–¥–∞–ª–∏—Ç–∏ –≤–∞—à—ñ —Ç–∞—Å–∫–∏\n\n"

                                            "<b>HomeWork</b>"
                                            "\n   /homeWorkAdd [–Ω–∞–∑–≤–∞ –ø—Ä–µ–¥–º–µ—Ç–∞], [–¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è]\n"
                                            "   /homeWorkInfo [–Ω–∞–∑–≤–∞ –ø—Ä–µ–¥–º–µ—Ç–∞] - –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–∞–Ω—ñ –ø—Ä–æ –≤–∞—à—ñ —Ç–∞—Å–∫–∏\n"
                                            "   /homeWorkMainInfo - –≤–∏–≤–æ–¥–∏—Ç—å –≤—Å–µ –≤–∞—à–µ –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è\n"
                                            "   /homeWorkDell [–Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç—É, –¥–µ –≤–∏ —Ö–æ—á–µ—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ –¥–∞–Ω—ñ]\n\n"
                                            
                                                                     
                                            "<b>–§—É–Ω–∫—Ü—ñ—ó —à—Ç—É—á–Ω–æ–≥–æ —ñ–Ω—Ç–µ–ª–µ–∫—Ç—É:</b>"
                                            "\n/iso [–≤–∞—à –∑–∞–ø–∏—Ç]\n"
                                            "/api [–≤–∞—à OpenAi key]\n"
                                            "/new_api [–≤–∞—à –Ω–æ–≤–∏–π OpenAi api-key]\n\n"
                                            "/generate_image [–≤–∞—à –∑–∞–ø–∏—Ç]\n"
                                            "/remove_background - –ø—ñ—Å–ª—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏ —Å–∫–∏–Ω—å—Ç–µ —Ñ–æ—Ç–æ, –¥–ª—è —è–∫–æ–≥–æ –≤–∏ –±–∞–∂–∞—î—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ background\n\n"
                                            "/uk_ocr - —Ä–æ–∑–ø—ñ–∑–Ω–∞—î —Ç–µ–∫—Å—Ç —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é —ñ–∑ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è\n"
                                            "/ocr - —Ä–æ–∑–ø—ñ–∑–Ω–∞—î —Ç–µ–∫—Å—Ç –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é, –Ω—ñ–º–µ—Ü—å–∫–æ—é, —Ñ—Ä–∞–Ω—Ü—É–∑—å–∫–æ—é –º–æ–≤–æ—é —ñ–∑ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è\n\n"
                                            
                                            "<b>–Ü–Ω—à—ñ —Ñ—É–Ω–∫—Ü—ñ—ó:</b>"
                                            "\n/resources [–≤–∞—à –∑–∞–ø–∏—Ç] - –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Å–∏–ª–∞–Ω—å –Ω–∞ —Å–∞–π—Ç–∏, –±–∞–∑—É—é—á–∏—Å—å –Ω–∞ –≤–∞—à–æ–º—É –∑–∞–ø–∏—Ç—ñ\n"
                                            "/info - –Ω–æ–≤–∏–Ω–∏\n"
                                            "/weather [–º—ñ—Å—Ç–æ]\n\n"
                                            "–¢–∞–∫–æ–∂ –±–æ—Ç –º–æ–∂–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç–∏ –∞—É–¥—ñ–æ—Ñ–∞–π–ª–∏ –∑ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—ó —Ç–∞ —Ä–æ—Å—ñ–π—Å—å–∫–æ—ó –º–æ–≤–∏", 
                           reply_markup=HELP)
    
    student.select_all()



"""                                                         """
"""                                                         """
"""                     Schedule functions                  """
"""                                                         """
"""                                                         """



"""                                                              """
"""                                                              """
"""                Get schedule time and send data               """


@dp.message_handler(commands=['new_schedule'])
async def new_schedule(message: types.Message):
    """
    This function is the handler for the '/new_schedule' command, which allows users to add a new schedule entry.

    Args:
        message (types.Message): The message object containing the command and its parameters.

    Result:
        Adds a new schedule entry to the database and prompts the user for confirmation.
    """
    
    
    """ 
    1. Update user information:
        - Get the user ID from the message.
        - Update the username and add the user to the database.

    """
    user_id = message.from_user.id
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)

    text = message.text.strip()
    

    """ 
    2. Parse and validate the command parameters:
        - Extract the text from the message.
        - Check if the command starts with '/' to ensure it's a valid command.
        - If a specific group is required to execute the command:
            - Check if the user has specified their group using the '/my_group' command.
            - If not, send a reply to the user requesting them to provide their group. 

    """
    if text.startswith("/"):

        command = text.split()[0]

        if command_groups.get(command, False):
            user_id = message.from_user.id

            if not student.check_group_for_user(user_id):
                
                await message.reply("<b>–î–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ –≤–∫–∞–∑–∞—Ç–∏ —Å–≤–æ—é –≥—Ä—É–ø—É –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –∫–æ–º–∞–Ω–¥ /my_group</b>")
                return
            
    if len(message["text"]) <= 13:
        await message.reply("<b>–ü—ñ—Å–ª—è /new_schedule –ù–∞–ø–∏—à—ñ—Ç—å  –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ, –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —á–∞—Å —É —Ñ–æ—Ä–º–∞—Ç—ñ –≥–æ–¥–∏–Ω–∞:—Ö–≤–∏–ª–∏–Ω–∞ (16:30)</b>\n–©–æ–± –≤—Å–µ –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–æ–±–∏—Ç–∏, –¥–∞–Ω—ñ –ø–∏—à—ñ—Ç—å —á–µ—Ä–µ–∑ –∫–æ–º—É, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥:\n/new_schedule <b> '–ü–æ–Ω–µ–¥—ñ–ª–æ–∫', '–≤–∏—â–∞ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞', '18:00'</b>")
        return
    list_data_to_insert_in_table = [x.strip() for x in message["text"][13:].split(",")]

    if len(list_data_to_insert_in_table)  < 3:
        print("len < 4")    
        await message.reply("<b>–ü—ñ—Å–ª—è /new_schedule –ù–∞–ø–∏—à—ñ—Ç—å  –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ, –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —á–∞—Å —É —Ñ–æ—Ä–º–∞—Ç—ñ –≥–æ–¥–∏–Ω–∞:—Ö–≤–∏–ª–∏–Ω–∞ (16:30)</b>\n–©–æ–± –≤—Å–µ –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–æ–±–∏—Ç–∏, –¥–∞–Ω—ñ –ø–∏—à—ñ—Ç—å —á–µ—Ä–µ–∑ –∫–æ–º—É, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥:\n/new_schedule <b> –ü–æ–Ω–µ–¥—ñ–ª–æ–∫, –≤–∏—â–∞ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞, 18:00</b>")
        return

    """
    3. Parse the schedule data from the message:
        - Remove any unwanted characters (double quotes, single quotes).
        - Split the text into separate words.
        - Extract the day of the week, subject, and start time from the words.
            - Find the day of the week by matching against a list of known days.
            - Find the subject by using a fuzzy matching algorithm.
            - Find the start time by matching against a regular expression or using fuzzy matching.
    """
    day_of_week = None
    group_name  = student.check_group_for_user(user_id)
    match_time  = None
    subject     = None
    
    message_text = message["text"][13:]  # Get message text starting from 12th character
    message_text = message_text.replace('"', '').replace("'", '')  # Remove double quotes and single quotes
    words = message_text.split(" ")  # Split text into separate words
    subject_list_data  =message_text.split(",")

    for word in words:
        match_day = process.extractOne(word, config.days_of_week, score_cutoff=70)
        match_subject = subject_list_data[1]

        """ Finding the subject in user input """
        if match_subject is not None and subject is None:
            subject = match_subject
        else:
            match_subject = process.extractOne(word, config.available_subjects, score_cutoff=50)
       
        """ Finding the day of the week in user input """
        if  match_day is not None :
            day_of_week = match_day[0]
        else:
            for day in config.days_of_week:
                if day in message_text: 
                    day_of_week = day   

        """Finding time of lesson"""
        pattern = r"\b\d{1,2}:\d{2}\b"  # Regular expression for finding time in HH:MM format
        
        match_time_main = re.search(pattern, text)
        if match_time_main:
            start_time = match_time_main.group()

        else:
            match_time = process.extractOne(word, config.time, score_cutoff=80)
            if match_time is None:
                await message.reply("<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–ø–∏—à—ñ—Ç—å —á–∞—Å –ø–æ—á–∞—Ç–∫—É –±–µ–∑ –ø—Ä–æ–±—ñ–ª—ñ–≤,  –ø—ñ—Å–ª—è –Ω–∞–∑–≤–∏ –¥–Ω—è –Ω–µ–¥—ñ–ª—ñ:\n/new_schedule –Ω–∞–∑–≤–∞ –≥—Ä—É–ø–∏, –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ–Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —á–∞—Å —É —Ñ–æ—Ä–º–∞—Ç—ñ –≥–æ–¥–∏–Ω–∞:—Ö–≤–∏–ª–∏–Ω–∞ (16:30)</b>")
                return
            start_time = match_time[0]
        

    
    """
    4. Validate the extracted data:
        - Check if the day of the week is found.
        - Check if the start time is found.
        - Check if the subject is found.
    """
    if  day_of_week is None:
        await message.reply("<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–ø–∏—à—ñ—Ç—å –Ω–∞–∑–≤—É –¥–Ω—è –Ω–µ–¥—ñ–ª—è –±–µ–∑ –ø—Ä–æ–±—ñ–ª—ñ–≤,  –ø—ñ—Å–ª—è –Ω–∞–∑–≤–∏ –≥—Ä—É–ø–∏:\n/new_schedule –Ω–∞–∑–≤–∞ –≥—Ä—É–ø–∏, –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ–Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —á–∞—Å —É —Ñ–æ—Ä–º–∞—Ç—ñ –≥–æ–¥–∏–Ω–∞:—Ö–≤–∏–ª–∏–Ω–∞ (16:30)</b>")
        return   
    if start_time is None:
        await message.reply("<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–ø–∏—à—ñ—Ç—å —á–∞—Å –ø–æ—á–∞—Ç–∫—É –±–µ–∑ –ø—Ä–æ–±—ñ–ª—ñ–≤,  –ø—ñ—Å–ª—è –Ω–∞–∑–≤–∏ –¥–Ω—è –Ω–µ–¥—ñ–ª—ñ:\n/new_schedule –Ω–∞–∑–≤–∞ –≥—Ä—É–ø–∏, –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ–Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —á–∞—Å —É —Ñ–æ—Ä–º–∞—Ç—ñ –≥–æ–¥–∏–Ω–∞:—Ö–≤–∏–ª–∏–Ω–∞ (16:30)</b>")
    if  subject is None:
        await message.reply("<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–ø–∏—à—ñ—Ç—å –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞ —â–µ —Ä–∞–∑\n/new_schedule –Ω–∞–∑–≤–∞ –≥—Ä—É–ø–∏, –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ–Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —á–∞—Å —É —Ñ–æ—Ä–º–∞—Ç—ñ –≥–æ–¥–∏–Ω–∞:—Ö–≤–∏–ª–∏–Ω–∞ (16:30)</b>")
    

    """
    
    5. Add the schedule entry:
        - If the extracted data is valid:
            - Display the extracted data to the user for confirmation.
            - Check if the time slot is already booked.
            - If not, add the schedule entry to the database.
            - Send a reply to the user confirming the added schedule entry.
        - If the data is incomplete or invalid:
            - Send a reply to the user requesting them to provide the missing or correct data.

    """
    if scheduleTable.check_booked_time(group_name, day_of_week, start_time) == False:
        await message.reply(f"‚ùå –¶–µ–π —á–∞—Å–æ–≤–∏–π –ø—Ä–æ–º—ñ–∂–æ–∫ –≤–∂–µ –æ–±—Ä–∞–Ω:")
        return
    await message.reply(f"<b>–Ü–º'—è –≥—Ä—É–ø–∏ - {group_name.lower().title()}\n–¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ - {day_of_week.lower().title()}\n–ù–∞–∑–≤–∞ –ø—Ä–µ–¥–º–µ—Ç—É - {subject.lower().title()}\n–ü–æ—á–∞—Ç–æ–∫ - {start_time}\n–ü—ñ–¥—Ç–≤–µ—Ä–¥—ñ—Ç—å:</b>", reply_markup=keyboard_third)
 

    
"""                                                              """
"""     Check schedule and sending notification about lessons    """
"""                                                              """


async def check_schedule_for_all_groups():
    """
    Asynchronous task that periodically checks the schedules 
        of all users and sends reminders for upcoming lessons

    Args:
            No arguments are specified for this function. 
                The function relies on external dependencies 
                    such as the `student` object and the `bot` object, which are Database Class.

    Result:
        The function ensures that users receive timely notifications about their upcoming lessons. It retrieves the user schedules, calculates the time until the next lesson, and sends reminders when the lesson is about to start. The function also clears the sent messages after a specified interval to avoid repetitive reminders.
    """

    sent_messages = {}  # Dictionary to track sent messages for each user
    clear_interval = 30 * 60  # Clear messages every 30 minutes
    last_clear_time = time.time()
    
    while True:
        now = datetime.now().time()
        users_id = student.select_users_id()
      
        user_schedules = {}  # Dictionary to store user schedules

        # Clear sent messages if the specified interval has passed
        current_time = time.time()
        if current_time - last_clear_time >= clear_interval:
            sent_messages.clear()
            last_clear_time = current_time
    
        # Retrieve schedules for all users
        for id_data in users_id:
            try:
                tgUserSchedule = scheduleTable.get_schedule_data_using_telegramID(id_data[0], bot_utils.find_weekday())
                if tgUserSchedule is False:
                    continue
                user_schedules[id_data[0]] = tgUserSchedule
                if id_data[0] not in sent_messages:
                    sent_messages[id_data[0]] = set()  # Initialize set for tracking sent messages
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ chat ID: {e}")
                continue

        # Iterate over user schedules and check for upcoming lessons
        for user_id, tgUserSchedule in user_schedules.items():
            for data in tgUserSchedule:
                subject = data[0]
                timeStart = data[1]
                lesson_start_time = datetime.strptime(timeStart, '%H:%M').time()
                time_until_lesson = timedelta(seconds=int((datetime.combine(datetime.today(), lesson_start_time) - datetime.combine(datetime.today(), now)).total_seconds()))
                print(f"time_until_lesson: {time_until_lesson}, user_id: {user_id}, subject: {subject}")

                if time_until_lesson <= timedelta(minutes=5) and time_until_lesson >= timedelta():
                    if subject not in sent_messages[user_id]:  # Check if message was already sent
                        try:
                            message = (
                                f"–î–æ  \"{subject}\" –∑–∞–ª–∏—à–∏–ª–æ—Å—å –º–µ–Ω—à–µ 5 —Ö–≤–∏–ª–∏–Ωüò±üò±üò±\n"
                                f"–ü–æ—Å–∏–ª–∞–Ω–Ω—è: \nhttps://teams.microsoft.com/_#/calendarv2"
                            )

                            await bot.send_message(chat_id=user_id, text=message)
                            
                        except exceptions.CantInitiateConversation:
                            sent_messages[user_id].add(subject)  # Add subject to set of sent messages

        await asyncio.sleep(240)



"""                                                                                       """
"""     Return schedule of day, using database group name data, linking to telegram id    """
"""                                                                                       """

@dp.message_handler(commands=['schedule_day'])
async def schedule_day(message: types.Message, day_num: str = None):
    """
    This function handles the '/schedule_day' command to retrieve the schedule for a specific day.
    Args:
        message ['Day of week']:
            day_num (optional): The day of the week specified in the command (e.g., '–ü–æ–Ω–µ–¥—ñ–ª–æ–∫'). Defaults to None.
    Result:
        None
    """
    if message["from"]["is_bot"] == True:
        user_id = message["chat"]["id"]
        # Here was correcting
        student.update_username(user_id, message["chat"]["first_name"])
        student.add_user(user_id, message["chat"]["first_name"])

    else:
        user_id = message.from_user.id
        student.update_username(user_id, message.from_user.first_name)
        student.add_user(user_id, message.from_user.first_name)
    
    text = message.text.strip()
    

    # Whether the text is a command

    """ Handle commands """
    if text.startswith("/"):
        # team name
        command = text.split()[0]
        # whether a group is needed to execute the command
        print(command)
        if command_groups.get(command, False):
            # Get user id
            user_id = user_id

            # Check if the user has specified their group
            if not student.check_group_for_user(user_id):
                await message.reply("<i>–î–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ –≤–∫–∞–∑–∞—Ç–∏ —Å–≤–æ—é –≥—Ä—É–ø—É –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –∫–æ–º–∞–Ω–¥ /my_group</i>")
                return
            
    
    if len( message["text"] ) <= 16:
        await message.reply("–ü—ñ—Å–ª—è /schedule_day –ù–∞–ø–∏—à—ñ—Ç—å –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥:\n/schedule_day –ü–æ–Ω–µ–¥—ñ–ª–æ–∫")
        
    else:
        group_name = student.check_group_for_user(user_id)
        current_day_schedule = scheduleTable.get_schedule_message(group_name, message['text'][16:].strip())
        day = message["text"][16:].strip()
   
        choices = ['–ü–æ–Ω–µ–¥—ñ–ª–æ–∫', '–í—ñ–≤—Ç–æ—Ä–æ–∫', '–°–µ—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', "–ü'—è—Ç–Ω–∏—Ü—è", '–°—É–±–æ—Ç–∞', '–ù–µ–¥—ñ–ª—è']
        match = process.extractOne(day, choices)
     
        available_groups = scheduleTable.select_all_groups()
        available_groups_text = " "
        if match[1] > 60:  # minimum similarity threshold
            current_day_schedule = scheduleTable.get_schedule_message(group_name, match[0])
            print(current_day_schedule)
            if current_day_schedule:
                schedule_message = " "
                # do something
                for item in current_day_schedule:
                    formatting_message = f"<b>{item[0]}</b> :  <b>{item[1]}</b>\n"
                    print(f"{item[0]} : {item[1]}")
                    schedule_message += formatting_message
                await message.reply(f"<b>–£ {match[0]} —É –í–∞—Å:\n{schedule_message}</b>")
            else:
                await message.reply(f"No schedule found for {match[0]}.")      
        else:
            if not len( message["text"] ) <= 13:
                await message.reply("–î–µ–Ω—å –Ω–µ–≤—ñ—Ä–Ω–∏–π")
        



"""                                                                                            """
"""     Just schedule of current day, using database group name data, linking to telegram id   """
"""                                                                                            """
@dp.message_handler(commands=['schedule'])
async def test_schedule(message: types.Message):
    """
    This function handles the '/schedule' command to retrieve the schedule for the current day.
    Args:
        None

    Result:
        None
    """

    current_time = time.strftime("%H:%M")
   
    user_id = message.from_user.id
    current_day_schedule = scheduleTable.get_schedule_message(student.check_group_for_user(user_id), bot_utils.find_weekday())
   
    if current_day_schedule:
        schedule_message = " "
        for item in current_day_schedule:
            formatting_message = f"<b>{item[0]}</b> :  <b>{item[1]}</b>\n"
           
            schedule_message += formatting_message
   
        await bot.send_message(message.chat.id, f"–†–æ–∑–∫–ª–∞–¥ {bot_utils.find_weekday()}:\n{schedule_message}")
    else:
        await bot.send_message(message.chat.id, "<b>–ù–∞ —Å—å–æ–≥–æ–¥–Ω—ñ —É –≤–∞—Å –Ω–µ–º–∞—î –∑–∞–Ω—è—Ç—å, –∞–±–æ –≤–∏ –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏ —ó—Ö —É —Å–≤—ñ–π —Ä–æ–∑–∫–ª–∞–¥:\n/new_schedule</b>")



"""                                                              """
"""                  HomeWork adding and checking                """
"""                                                              """
"""                                                              """

@dp.message_handler(commands=['homeWorkAdd'])
async def homeWork(message: types.Message):
    """
    Handles the '/homeWorkAdd' command and processes the user's input to add homework tasks.

    Args:
        message: The message object containing the user's input: [subject name] [homework]

    Returns:
        None
        To database writing user homework data 
    """

    user_id = message.from_user.id

    if len(message["text"]) <= 9:
        await message.reply(f"{message.from_user.first_name}, –ü—ñ—Å–ª—è <b>/homeWorkAdd –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —Ç–∞ –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è</b>, —á–µ—Ä–µ–∑ –∫–æ–º—É")
        return
    data = message.text[9:].split(",")  # Get the text of the task by removing '/homeWork ' from the message
    if len(data) < 2:
        await message.reply(f"{message.from_user.first_name}, –ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è <b>/homeWorkAdd –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —Ç–∞ –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è</b>, —á–µ—Ä–µ–∑ –∫–æ–º—É")
        return
    homework = "" 
    for word in data:
        matchSubject = process.extractOne(word, config.available_subjects, score_cutoff=70)
        
        print(matchSubject)
        if matchSubject:
            subject = matchSubject[0]
            break
    homework = data[1:]
    homeWorkText = ' '.join(homework)
    if homeWorkText and subject:
        homeworkData.add_homework(user_id, subject, homeWorkText)

        homework_data = homeworkData.get_homework(user_id, subject)
        homeworkDataText = '\n'.join(f"{i+1}. {item}" for i, item in enumerate(homework_data))
        await message.reply(f"‚úÖ <b>–î–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è '{homeWorkText}' –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—É '{subject}' –±—É–ª–æ —É—Å–ø—ñ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ.\n{homeworkDataText}.</b>")
    else:
        await message.reply(f"{message.from_user.first_name}, –ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è <b>/homeWork –≤–≤–µ–¥—ñ—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —Ç–∞ –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è</b>, —á–µ—Ä–µ–∑ –∫–æ–º—É")


@dp.message_handler(commands=['homeWorkInfo'])
async def homeWorkInfo(message: types.Message):
    """
    Handles the '/homeWorkInfo's.

    Args:
        message: Subject name

    Returns:
        From database read user homework data, basing on his telegram id -> subject name
        Sending user homework data on special subject
    """
    user_id = message.from_user.id

    if len(message["text"]) <= 13:
        await message.reply(f"{message.from_user.first_name}, –ü—ñ—Å–ª—è <b>/homeWorkInfo –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞</b>")
        return
    
    user_subject_list = homeworkData.get_user_subjects(user_id)

    if len(user_subject_list) == 0:
        await message.reply(f"–ù–∞—Ä–∞–∑—ñ —É –≤–∞—Å –Ω–µ–º–∞—î –¥–æ–º–∞—à–Ω—å–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è –Ω—ñ –¥–ª—è —è–∫–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç—É.\n–©–æ–± –π–æ–≥–æ –¥–æ–±–∞–≤–∏—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å/homeWorkAdd –Ω–∞–∑–≤–∞ –ø—Ä–µ–¥–º–µ—Ç—É, –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è.</b>")
        return 
    
    matchSubject = process.extractOne(message["text"][13:], user_subject_list, score_cutoff=70)
 
    subject_list_text = '\n'.join(f"{i+1}. {item}" for i, item in enumerate(user_subject_list))
  
    if matchSubject is  None:
       await message.reply(f"{message.from_user.first_name}, <b>–Ω–∞–∑–≤–∏ –ø—Ä–µ–¥–º–µ—Ç—É, —è–∫–∏–π –≤–∏ –≤–∫–∞–∑–∞–ª–∏, –Ω–µ–º–∞—î —É –≤–∞—à–æ–º—É —Å–ø–∏—Å–∫—É. –ü—Ä–µ–¥–º–µ—Ç–∏, –ø–æ —è–∫–∏–º –≤–∏ –∑–∞–ø–∏—Å–∞–ª–∏ –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è:\n{subject_list_text}.</b>")
       return
    
    subject = matchSubject[0]

    try:
        homework_data = homeworkData.get_homework(user_id, subject)
        if len(homework_data) == 0:
            await message.reply(f"–ù–∞—Ä–∞–∑—ñ —É –≤–∞—Å –Ω–µ–º–∞—î –¥–æ–º–∞—à–Ω—å–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è —Ü—å–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç—É.\n–©–æ–± –π–æ–≥–æ –¥–æ–±–∞–≤–∏—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å/homeWorkAdd –Ω–∞–∑–≤–∞ –ø—Ä–µ–¥–º–µ—Ç—É, –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è.</b>")
            return 
        homeworkDataText = '\n'.join(f"{i+1}. {item}" for i, item in enumerate(homework_data))

        await message.reply(f"<b>–í–∞—à–µ –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—É '{subject}':\n{homeworkDataText}.</b>")

    except Exception as e:
        await message.reply(f"{message.from_user.first_name}, <b>–ø—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω–Ω—è, –≤–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ —É–∫–∞–∑–∞—Ç–∏ –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç—É</b>")
        return
   
 
@dp.message_handler(commands=['homeWorkDell'])
async def homeWorkDell(message: types.Message):
    """
    Delete homework data from database, basing on telegram id -> and subject name 
    """
    user_id = message.from_user.id
    if len(message["text"]) <= 13:
        await message.reply(f"{message.from_user.first_name}, <b>–ü—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /homeWorkDell –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç—É, –¥–µ –≤–∏ —Ö–æ—á–µ—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ –¥–∞–Ω—ñ.</b>")
        return
    
    user_subject_list = homeworkData.get_user_subjects(user_id)

    if len(user_subject_list) == 0:
        await message.reply(f"<b>–ù–∞—Ä–∞–∑—ñ —É –≤–∞—Å –Ω–µ–º–∞—î –¥–æ–º–∞—à–Ω—å–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è –Ω—ñ –¥–ª—è —è–∫–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç—É.\n–©–æ–± –π–æ–≥–æ –¥–æ–±–∞–≤–∏—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å:\n/homeWorkAdd –Ω–∞–∑–≤–∞ –ø—Ä–µ–¥–º–µ—Ç—É, –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è</b>")

        return 
    
    matchSubject = process.extractOne(message["text"][13:], user_subject_list, score_cutoff=70)
    
    if matchSubject is None:
       await message.reply(f"{message.from_user.first_name}, <b>–ù–∞–∑–≤–∏ –ø—Ä–µ–¥–º–µ—Ç—É, —è–∫–∏–π –≤–∏ –≤–∫–∞–∑–∞–ª–∏, –Ω–µ–º–∞—î —É –≤–∞—à–æ–º—É —Å–ø–∏—Å–∫—É. –ü—Ä–µ–¥–º–µ—Ç–∏, –ø–æ —è–∫–∏–º –≤–∏ –∑–∞–ø–∏—Å–∞–ª–∏ –¥–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è:\n{subject_list_text}.</b>")
       return
    
    subject = matchSubject[0]
    
    try:
        homeworkData.remove_homework_from_subject(user_id, subject)
        user_subject_list = homeworkData.get_user_subjects(user_id)
        subject_list_text = '\n'.join(f"{i+1}. {item}" for i, item in enumerate(user_subject_list))
        if len(user_subject_list) > 0:
            await message.reply(f"<b>–î–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—É '{subject}' –±—É–ª–æ –≤–∏–¥–∞–ª–µ–Ω–æ.\n –ü—Ä–µ–¥–º–µ—Ç–∏ –∑ –Ω–∞—è–≤–Ω–∏–º –¥–æ–º–∞—à–Ω—ñ–º –∑–∞–≤–¥–∞–Ω–Ω—è–º:\n{subject_list_text}</b>")
        else:
            await message.reply(f"<b>–î–æ–º–∞—à–Ω—î –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—É '{subject}' –±—É–ª–æ –≤–∏–¥–∞–ª–µ–Ω–æ.\n–ù–∞—Ä–∞–∑—ñ —É –≤–∞—Å –Ω–µ–º–∞—î –¥–æ–º–∞—à–Ω—å–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è –Ω—ñ –¥–ª—è —è–∫–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç—É.</b>")

    except Exception as e:
        await message.reply(f"{message.from_user.first_name}, <b>–ø—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω–Ω—è, –≤–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ —É–∫–∞–∑–∞—Ç–∏ –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç—É</b>")
        return


@dp.message_handler(commands=['homeWorkMainInfo'])
async def homeWorkMainInfo(message: types.Message):
    """
    Sending user homework data about all his subject, that he have 
    """
    user_id = message.from_user.id
 
    user_subject_list = homeworkData.get_user_subjects(user_id)
    
    user_home_work_list = []
    for homework in user_subject_list:
        subject_dict = {}
        subject_dict["key"] = homework
        subject_dict["value"] = homeworkData.get_homework(user_id, homework)
        user_home_work_list.append(subject_dict)
    
    if len(user_home_work_list) == 0:
        await message.reply(f"<b>–ù–∞—Ä–∞–∑—ñ —É –≤–∞—Å –Ω–µ–º–∞—î  –¥–æ–º–∞—à—å–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è –Ω—ñ –¥–ª—è –∂–æ–¥–Ω–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç—É.</b>")
        return
    
    response_text = ""
    for item in user_home_work_list:
        response_text += f"\n{item['key']}\n"
        for i, value in enumerate(item['value'], start=1):
            response_text += f"{i}. {value}\n"
    
    await message.reply(f"<b>{response_text}</b>")
    





"""                                                              """
"""                     Document Creating                        """
"""                                                              """
"""                                                              """
@dp.message_handler(commands=['doc', 'docs'])
async def newDoc(message: types.Message):
    """
    Generates a document title based on the user's input and sends it back to the user.
    File creating and processing in ---bot_utils--- file, ---document_creating--- function
    Args:
        message: The message object containing the user's input.

    Returns:
        Send document .docx to user
    """

    # Checking if the command has enough arguments

    if len(message["text"]) <= 5:
        await message.reply(f"{message.from_user.first_name}, <b>–ü—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /doc –Ω–∞–ø–∏—à—ñ—Ç—å:\n–ù–∞–∑–≤—É –¥–∏—Å—Ü–∏–ø–ª—ñ–Ω–∏, –Ω–∞–∑–≤—É –≥—Ä—É–ø–∏, —ñ–º'—è —Å—Ç—É–¥–µ–Ω—Ç–∞, —ñ–º'—è –≤—á–∏—Ç–µ–ª—è\n–©–æ–± –≤—Å–µ –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–æ–±–∏—Ç–∏, –Ω–∞–ø—à—ñ—Ç—å –¥–∞–Ω—ñ —á–µ—Ä–µ–∑ –∫–æ–º—É</b>")
        return
    doc_data = message["text"][5:].split(",")
  
    if not len(doc_data) == 4:
        await message.reply(f"{message.from_user.first_name}, <b>–ü—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /doc —Ç—Ä–µ–±–∞ –Ω–∞–ø–∏—Å–∞—Ç–∏:\n–ù–∞–∑–≤—É –¥–∏—Å—Ü–∏–ø–ª—ñ–Ω–∏, –Ω–∞–∑–≤—É –≥—Ä—É–ø–∏, —ñ–º'—è —Å—Ç—É–¥–µ–Ω—Ç–∞, —ñ–º'—è –≤—á–∏—Ç–µ–ª—è\n–©–æ–± –≤—Å–µ –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–æ–±–∏—Ç–∏, –Ω–∞–ø—à—ñ—Ç—å –¥–∞–Ω—ñ —á–µ—Ä–µ–∑ –∫–æ–º—É</b>")
        return
    try:
        # Creating the document using the provided data

        bot_utils.document_creating(doc_data[0], doc_data[1], doc_data[2], doc_data[3])
        with open('yourVariant.docx', 'rb') as file:
        # Sending a file to a user
            await bot.send_document(message.chat.id, document=file)
            os.remove('yourVariant.docx')
    except Exception as e:
        print(e)
        await message.reply(f"{message.from_user.first_name}, <b>–≤–∏ –≤–≤–µ–ª–∏ –Ω–µ–≤—ñ—Ä–Ω—ñ –¥–∞–Ω—ñ.\n–ü—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /doc –Ω–∞–ø–∏—à—ñ—Ç—å:\n–ù–∞–∑–≤—É –¥–∏—Å—Ü–∏–ø–ª—ñ–Ω–∏, –Ω–∞–∑–≤—É –≥—Ä—É–ø–∏, —ñ–º'—è —Å—Ç—É–¥–µ–Ω—Ç–∞, —ñ–º'—è –≤—á–∏—Ç–µ–ª—è\n–©–æ–± –≤—Å–µ –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–æ–±–∏—Ç–∏, –Ω–∞–ø–∏—à—ñ—Ç—å –¥–∞–Ω—ñ —á–µ—Ä–µ–∑ –∫–æ–º—É</b>")
   
    


@dp.message_handler(commands=['specialDoc'])
async def create_document(message: types.Message):
    """
    Generates a document based on the user's input, chatgpt answers and sends it back to the user.
    File creating and processing in ---bot_utils--- file, ---document_creating_for_speccial_topic--- function
    it use AI_responce_without_log functions to get chatgpt responce, that using in document
    Args:
        message: The message object containing the user's input.

    Returns:
        Send document .docx to user
    """
    if len(message["text"]) <= 11:
        await message.reply(f"{message.from_user.first_name}, –ü—ñ—Å–ª—è /specialDoc –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É —Ç–µ–º–∏")
        return
    try:
        bot_utils.document_creating_for_speccial_topic(message["text"][11:])
        with open('yourVariant.docx', 'rb') as file:
        # Sending a file to a user
            await bot.send_document(message.chat.id, document=file)
            os.remove('yourVariant.docx')
    except Exception as e:
        print(e)
        await message.reply(f"<b>–ü—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω–Ω—è, –∑–∞—Ä–∞–∑ —É —Å–µ—Ä–≤–µ—Ä–∞—Ö OpenAi –¥–µ—è–∫—ñ —Ç–µ—Ö–Ω—ñ—á–Ω—ñ –Ω–µ–ø–æ–ª–∞–¥–∫–∏.</b>")





"""                                                                     """
"""                                                                     """
"""                                                                     """
"""                                                                     """
"""         Translating and insert to DB user words                     """
"""         Main Aim: to learn new words from differenst languages      """
"""                                                                     """
"""                                                                     """
"""                                                                     """

@dp.message_handler(commands=['word', 'uword'])
async def newWord(message: types.Message):
    """
    Handles the '/word' and '/uword' commands.

    Args:
        message: The message object containing the command and text.

    Action:
        1. Translates the word and sends the translation to the user.
        2. Adds the translated word to the dictionary (DB).

    Comments:
        - The function handles two commands: '/word' and '/uword'.
        - '/word' command: Translates the word to Ukrainian and sends the translation to the user.
        - '/uword' command: Translates the specified Ukrainian text to the specified language and sends the translation to the user.
        - If the command is not followed by valid parameters, appropriate error messages are sent.
        - The translated word is added to the dictionary with the corresponding language.
    """
    user_id = message.from_user.id
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    
    # Check if the message length is less than or equal to 5
    if len(message.text) <= 5:
        await message.answer("<b>–ü—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /word –≤–≤–µ–¥—ñ—Ç—å —Ç–µ–∫—Å—Ç</b>")
        return

    word = message.text[6:]
    is_uword_command = 'uword' in message.text[1:]

    # Handle '/uword' command
    if is_uword_command:
        # Check if the command is followed by the language and the text to translate
        if len(message.text) <= 6:
            await message.answer(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /uword –Ω–∞–ø–∏—à—ñ—Ç—å –º–æ–≤—É, –Ω–∞ —è–∫—É —Ç—Ä–µ–±–∞ –∑—Ä–æ–±–∏—Ç–∏ –ø–µ—Ä–µ–∫–ª–∞–¥, —ñ —Ç–µ–∫—Å—Ç —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥:\n/uword –ù—ñ–º–µ—Ü—å–∫–∞, –Ø–∫ —Å–ø—Ä–∞–≤–∏?</b>")
            return

        process_text = word.strip().split(",")
        if len(process_text) < 2:
            await message.answer(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –æ–¥—Ä–∞–∑—É –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /uword –Ω–∞–ø–∏—à—ñ—Ç—å –º–æ–≤—É, –Ω–∞ —è–∫—É —Ç—Ä–µ–±–∞ –∑—Ä–æ–±–∏—Ç–∏ –ø–µ—Ä–µ–∫–ª–∞–¥, —ñ —Ç–µ–∫—Å—Ç —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é,  –Ω–∞–ø—Ä–∏–∫–ª–∞–¥:\n/uword –ù—ñ–º–µ—Ü—å–∫–∞, –Ø–∫ —Å–ø—Ä–∞–≤–∏?</b>")
            return

        sentence_to_translate = "".join(process_text[1:])
        print(sentence_to_translate)

        # Extract the language and check if it is valid
        lang = process.extractOne(process_text[0], bot_utils.language_names.values(), score_cutoff=60)
        if lang is None:
            await message.answer(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /uword –Ω–∞–ø–∏—à—ñ—Ç—å –º–æ–≤—É —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é.</b>")
            return

        detected_language = next(key for key, val in bot_utils.language_names.items() if val == lang[0])
        
        # Translate the text and send the response
        translated_word = bot_utils.translate_text(text=sentence_to_translate, source_lang="uk", target_lang=detected_language, detect_language=False)
        await message.answer(f"<b>–ü–µ—Ä–µ–∫–ª–∞–¥ –∑ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—ó –Ω–∞ {lang[0]}:\n\n{translated_word}</b>")
        translated_word += '.'
        wordDataBase.add_word(user_id, lang[0].capitalize(), translated_word)
        return

    
    translated_word, source_lang = bot_utils.translate_text(text=word, source_lang="", target_lang="uk", detect_language=True)

    try:
        examples = bot_utils.AI_responce_without_log(message=f"–ü–µ—Ä–µ–≤–µ–¥–∏ —Å–ª–æ–≤–æ '{word}' —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é, —Ç–∞ –Ω–∞–ø–∏—à–∏  3 –ø—Ä–∏–∫–ª–∞–¥–∏ –¥–ª—è —Å–ª–æ–≤–∞ {word} –Ω–∞ {source_lang} –º–æ–≤—ñ, –±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω—å.", language_target=True)
        await message.answer(f"<b>{examples}</b>")
    except openai.error.RateLimitError:
        await message.answer(f"<b>–ü—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω–Ω—è, –∑–∞–±–∞–≥–∞—Ç–æ –∑–∞–ø–∏—Ç—ñ–≤ –∫ OpenAi</b>")
        
    translated_word += '.'
    wordDataBase.add_word(user_id, source_lang.capitalize(), word)
    
   
async def words_list_callback(callback_query: types.CallbackQuery):
    """
    Handler  the '/word_list' command.

    Args:
        callback_query: The callback query object.

    Action:
        Send to user a word-list 
    """
    user_id = callback_query.from_user.id

    # Retrieve all words data for the user
    test = wordDataBase.display_all_data(user_id)

    words_dict = dict(test)
    response = ""
    # Iterate over the languages and phrases in the words dictionary
    for language, phrases in words_dict.items():
        response += f"{language}:\n"
        # Clean up the phrases string and split into a list
        phrases = phrases.replace("[", "").replace("]", "").replace("'", "")
        phrases_list = phrases.strip().split(".")
    

        # Iterate over the phrases list and add them to the response
        for i, phrase in enumerate(phrases_list, 1):
            response += f"   {i}. {phrase}\n"
    response = response.strip()

    
    await bot.send_message(callback_query.message.chat.id ,f"<b>–í—Å—ñ —Å–ª–æ–≤–∞:\n{response}</b>")



@dp.message_handler(commands=['word_list', 'list_word'])
async def words_list(message: types.Message):
    """
    Handler for the 'word_list' command. list_word make the same

    Args:
        None.

    Action:
        Get user dictionary from DB and send it to him.
    """


    user_id = message.from_user.id
    
    print(message)

    # Retrieve all words data for the user
    test = wordDataBase.display_all_data(user_id)
    if len(test) == 0:
        await message.reply(f"<b>–£ –≤–∞—Å –Ω–µ–º–∞—î –Ω–∞—è–≤–Ω–∏—Ö —Å–ª—ñ–≤</b>")
        return
    words_dict = dict(test)
    response = ""
    for language, phrases in words_dict.items():
        response += f"{language}:\n"
        phrases_list = eval(phrases)  # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –≤ —Å–ø–∏—Å–æ–∫ —Å –ø–æ–º–æ—â—å—é eval()
        for i, phrase in enumerate(phrases_list, 1):
            response += f"   {i}. {phrase}\n"
    
    await message.reply(f"<b>{response}</b>")
  

@dp.message_handler(commands=['certain_words'])
async def certainWordList(message: types.Message):
    """
    Handler  the 'certain_words' command.

    Args:
        Language

    Action:
        Give user a list of his words in certain language.
    """
    user_id = message.from_user.id
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)

    # Check if the command is followed by a language
    if len(message["text"]) <= 14:
        await message.reply(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /certainWord –≤–≤–µ–¥—ñ—Ç—å –º–æ–≤—É, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –≤–∞—à–∏—Ö —Å–ª—ñ–≤.</b>")
        return
    
    # Extract the language and retrieve specific language words for the user
    language = process.extractOne(message["text"][15:], bot_utils.language_names.values(), score_cutoff=60)
    test = wordDataBase.get_specific_language_words(user_id, language[0].capitalize())
    if len(test) == 0:
        await message.reply(f"<b>–î–ª—è –≤–∞—à–æ—ó –º–æ–≤–∏ –Ω–µ –±—É–ª–æ –∑–Ω–∞–π–¥–µ–Ω–æ —Å–ª—ñ–≤\n–°–ø–∏—Å–æ–∫ –º–æ–≤ —Ç–∞ –≤–∞—à–∏—Ö —Å–ª—ñ–≤:\n</b>")
        await words_list(message)
        return
    response = f"{language[0].capitalize()}:\n"

    # Iterate over the specific language words and add them to the response
    for i, word in enumerate(test, 1):
        response += f"  {i}. {word}\n"

    await message.reply(f"<b>{response}</b>")



@dp.message_handler(commands=['word_done'])
async def word_done(message: types.Message):
    """
    This function handles the '/word_done' command. It marks a word as completed for a specific language.

    Args:
    - message: The message object containing the command and arguments.

    Result:
    - The function marks the specified word as completed for the given language and sends a response message.

    """
    user_id = message.from_user.id

    if len(message["text"]) <= 10:
        await message.reply(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /word_done –Ω–∞–ø–∏—à—ñ—Ç—å –º–æ–≤—É, —Ç–∞ –Ω–æ–º–µ—Ä —Å–ª–æ–≤–∞, —è–∫–∏–π –≤–∏ –≤–∂–µ –≤–∏–≤—á–∏–ª–∏. –ù–∞–ø—Ä–∏–∫–ª–∞–¥:\n/word_done –ù—ñ–º–µ—Ü—å–∫–∞, 1</b>")
        return
    
    message_main = message["text"][11:].split(",")
    if not len(message_main) == 2:
        await message.reply(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /word_done –Ω–∞–ø–∏—à—ñ—Ç—å –º–æ–≤—É, —Ç–∞ –Ω–æ–º–µ—Ä —Å–ª–æ–≤–∞, —è–∫–∏–π –≤–∏ –≤–∂–µ –≤–∏–≤—á–∏–ª–∏. –ù–∞–ø—Ä–∏–∫–ª–∞–¥:\n/word_done –ê–Ω–≥–ª—ñ–π—Å—å–∫–∞, 1</b>")
        return
    
    user_language = message_main[0].strip()
    index = message_main[1].strip()
    print(index)

    if index.isnumeric() == False:
        await message.reply(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–ø—ñ—à–∏—Ç—å –Ω–æ–º–µ—Ä —Å–ª–æ–≤–∞, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥: 1</b>")
        return
    
    language = process.extractOne(user_language, bot_utils.language_names.values(), score_cutoff=60)
  
    if language is None:
        await message.reply(f"<b>–ù–µ –±—É–ª–æ –∑–Ω–∞–π–¥–µ–Ω–æ –º–æ–≤–∏</b>")
        return

    test = wordDataBase.get_specific_language_words(user_id, language[0].capitalize())
    
    if len(test) == 0:
        await message.reply(f"<b>–î–ª—è –º–æ–≤–∏ '{language[0].capitalize()}' –Ω–µ –±—É–ª–æ –∑–Ω–∞–π–¥–µ–Ω–æ –≤–∞—à–∏—Ö —Å–ª—ñ–≤.</b>")
        return
    
    print(language[0].capitalize())
    check_list = wordDataBase.add_checkmark_to_word(user_id, language[0].capitalize(), int(index) - 1)
    
    words_done = 0 
    for sentence in test:
        if "‚úÖ" in sentence:
            words_done += 1
    if len(test) == words_done:
        response = f"{language[0].capitalize()}:\n"
        # Iterate over the specific language words and add them to the response
        for i, word in enumerate(test, 1):
            response += f"  {i}. {word}\n"  
        await message.reply(f"<b>Check Mark –±—É–≤ –¥–æ–±–∞–≤–ª–µ–Ω –∫–æ –≤—Å—ñ–º —Å–ª–æ–≤–∞–º –¥–æ –º–æ–≤–∏ {language[0].capitalize()}:\n{response}\n</b>\n–í–∏–¥–∞–ª–∏—Ç–∏ —Å–ª–æ–≤–∞?", reply_markup=keyboard_five)
        
        return
    
    if check_list == False:
        await message.reply(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –¥—ñ–π—Å–Ω–∏–π –Ω–æ–º–µ—Ä —Å–ª–æ–≤–∞.</b>")
        
        response = f"{language[0].capitalize()}:\n"
        # Iterate over the specific language words and add them to the response
        for i, word in enumerate(test, 1):
            response += f"  {i}. {word}\n"
            
        await message.reply(f"<b>{response}</b>")
        
        return
    
    if check_list == "Its was checked":
        await message.reply(f"<b>Check list –≤–∂–µ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ —Ü—å–æ–º—É –Ω–æ–º–µ—Ä—É —Å–ª–æ–≤–∞</b>")
        return
    
    test = wordDataBase.get_specific_language_words(user_id, language[0].capitalize())
    
    response = f"{language[0].capitalize()}:\n"
    # Iterate over the specific language words and add them to the response
    for i, word in enumerate(test, 1):
        response += f"  {i}. {word}\n"
            
    await message.reply(f"<b>Check Mark –±—É–≤ –¥–æ–±–∞–≤–ª–µ–Ω:\n{response}</b>")
    
    


@dp.message_handler(commands=['remove_words'])
async def remove_words(message: types.Message):
    """
    This function handles the '/remove_words' command. It removes all words for a specific language.

    Args:
        - message: The message object containing the command and arguments.

    Result:
        - The function removes all words for the specified language and sends a response message.
    """

    user_id = message.from_user.id

    if len(message['text']) <= 13:
        await message.reply(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /remove_words –Ω–∞–ø–∏—à—ñ—Ç—å –º–æ–≤—É.</b>")
        return

    process_text = message['text'][14:].strip()
    language = process.extractOne(process_text, bot_utils.language_names.values(), score_cutoff=60)
    if language is None:
        await message.answer(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /remove_words –Ω–∞–ø–∏—à—ñ—Ç—å –º–æ–≤—É —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é.</b>")
        return
    
    test = wordDataBase.get_specific_language_words(user_id, language[0].capitalize())
    
    if len(test) == 0:
        await message.reply(f"<b>–î–ª—è –º–æ–≤–∏ '{language[0].capitalize()}' –Ω–µ –±—É–ª–æ –∑–Ω–∞–π–¥–µ–Ω–æ –≤–∞—à–∏—Ö —Å–ª—ñ–≤.</b>")
        return
    
   
    wordDataBase.remove_words_by_language(user_id, language[0].strip().capitalize())
    await message.reply(f"<b>–°–ª–æ–≤–∞ –¥–ª—è –º–æ–≤–∏ '{language[0].capitalize()}' –ë—É–ª–∏ –≤–∏–¥–∞–ª–µ–Ω—ñ.</b>")
    await words_list(message)





"""                                                              """
"""                         Todo list                            """
"""                                                              """
"""                                                              """

@dp.message_handler(commands=['new_task'])
async def new_task(message: types.Message):
    
    """
    This function handles the '/new_task' command. It writes a new user task to the database.

    Args:
        - message: The message object containing the user's input.

    Result:
        - The function adds the user's task to the database and sends a response message.
    """


    user_id = message.from_user.id
    if len(message["text"]) <= 9:
        await message.reply(f"{message.from_user.first_name}, –ü—ñ—Å–ª—è /new_task –≤–≤–µ–¥—ñ—Ç—å —Å–≤—ñ–π —Ç–∞—Å–∫")
        return
    task = message.text[9:]  # Get the text of the task by removing '/add ' from the message
    if not student.add_task(user_id, task):
        tasks = student.get_tasks(user_id)
        tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)])  
        await message.reply(f"<b>üòû –õ—ñ–º—ñ—Ç —Ç–∞—Å–∫—ñ–≤ - 10\n\n{tasks_text}</b>")
        return 
    tasks = student.get_tasks(user_id)

    tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)]) # Adding serial numbers to each element

    await message.reply(f"<b>ü•≥ –¢–∞—Å–∫ '{task}' –±—É–ª–æ —É—Å–ø—ñ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ\n{tasks_text}</b>")


@dp.message_handler(commands=['task_list'])
async def task_list(message: types.Message):
    """
    This function handles the '/task_list' command. It returns the user's task data.

    Args:
        - message: The message object (doesn't need to contain user input).

    Result:
        - The function retrieves the user's tasks from the database and sends a response message.
    """
    user_id = message.from_user.id
    tasks = student.get_tasks(user_id)
    
    if len(tasks) == 0:
        await message.reply(f"<b>{message.from_user.first_name}, –Ω–∞—Ä–∞–∑—ñ —É –≤–∞—Å –Ω–µ–º–∞—î —Ç–∞—Å–∫—ñ–≤.\n–©–æ–± —ó—Ö –¥–æ–±–∞–≤–∏—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å –∫–æ–º–∞–Ω–¥—É:\n/new_task —Ç–∞ –Ω–∞–∑–≤–∞ –≤–∞—à–æ–≥–æ —Ç–∞—Å–∫—É</b>")
        return
    tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)])
    await message.reply(f"<b>–í–∞—à—ñ —Ç–∞—Å–∫–∏:\n{tasks_text}</b>")
   

@dp.message_handler(commands=['task_done'])
async def task_done(message: types.Message):
    """
    This function handles the '/task_done' command. It marks the user's task as done.

    Args:
        - message: The message object containing the user's input -> [task number]

    Result:
        - The function marks the specified task as completed in the database and sends a response message.
    """
    user_id = message.from_user.id
    tasks = student.get_tasks(user_id)
    
    if len(tasks) == 0:
        await message.reply(f"<b>{message.from_user.first_name}, —É –≤–∞—Å –Ω–µ–º–∞—î —Ç–∞—Å–∫—ñ–≤.\n–©–æ–± —ó—Ö –¥–æ–±–∞–≤–∏—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å –∫–æ–º–∞–Ω–¥—É:\n/new_task —Ç–∞ –Ω–∞–∑–≤–∞ –≤–∞—à–æ–≥–æ —Ç–∞—Å–∫—É</b>")
        return
 
    if len(message["text"]) <= 10:
        await message.reply(f"<b>{message.from_user.first_name}, –ø—ñ—Å–ª—è /task_done –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–∞—Å–∫—É, —è–∫–∏–π  –≤–∏ –±–∞–∂–∞—î—Ç–µ –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —è–∫ –≤–∏—Ä—ñ—à–µ–Ω–∏–π</b>")
        return
    if not message["text"][11:].isdigit():
        await message.reply(f"<b>{message.from_user.first_name}, –±—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–∞—Å–∫—É</b>")
        return
    
    if int(message["text"][11:]) > len(tasks):
        await message.reply(f"<b>{message.from_user.first_name}, —Ç–∞—Å–∫—É –ø—ñ–¥ –Ω–æ–º–µ—Ä–æ–º, —è–∫–∏–π –≤–∏ –≤–≤–µ–ª–∏, –Ω–µ –¥—ñ–π—Å–Ω–∏–π</b>")
        return
    
    result = student.mark_task_as_completed(user_id, int(message["text"][11:]) - 1)
    
    if result == "–ó–∞–¥–∞—á–∞ –≤–∂–µ –≤—ñ–¥–º—ñ—á–µ–Ω–∞, —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–∞":
        await message.reply(f"<b>{message.from_user.first_name}, –∑–∞–¥–∞—á–∞ –≤–∂–µ –≤—ñ–¥–º—ñ—á–µ–Ω–∞, —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–∞</b>")
        return
    
    tasks = student.get_tasks(user_id)
    
    tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)])

    if len(tasks) >= 1:
        await message.reply(f"<b>–¢–∞—Å–∫ –ª—ñ—Å—Ç –±—É–ª–æ —É—Å–ø—ñ—à–Ω–æ –∑–º—ñ–Ω–µ–Ω–æ:\n{tasks_text}</b>")
    if result == "–í—Å—ñ —Ç–∞—Å–∫–∏ –≤–∏–∫–æ–Ω–∞–Ω—ñ":
        
        await message.reply(f"<b>–í—Å—ñ —Ç–∞—Å–∫–∏ –≤–∏–∫–æ–Ω–∞–Ω—ñ, —á–∏ –±–∞–∂–∞—î—Ç–µ –≤–∏ –≤–∏–¥–∞–ª–∏—Ç–∏ —ó—Ö?</b>", reply_markup=keyboard_four)
 

@dp.message_handler(commands=['taskRemove'])
async def taskRemove(message: types.Message):
    """
    This function handles the '/taskRemove' command. It removes the user's task.

    Args:
        - message: The message object containing the user's input -> [task number]

    Result:
        - The function removes the specified task from the database and sends a response message.
    """
    user_id = message.from_user.id
    tasks = student.get_tasks(user_id)
    
    
    if len(tasks) == 0:
        await message.reply(f"<b>{message.from_user.first_name}, —É –≤–∞—Å –Ω–µ–º–∞—î —Ç–∞—Å–∫—ñ–≤.\n–©–æ–± —ó—Ö –¥–æ–±–∞–≤–∏—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å –∫–æ–º–∞–Ω–¥—É:\n/new_task —Ç–∞ –Ω–∞–∑–≤–∞ –≤–∞—à–æ–≥–æ —Ç–∞—Å–∫—É</b>")
        return
    
    if len(message["text"]) <= 11:
        await message.reply(f"<b>{message.from_user.first_name}, –ø—ñ—Å–ª—è /taskRemove –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–∞—Å–∫—É, —è–∫–∏–π  –≤–∏ –±–∞–∂–∞—î—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏</b>")
        return
    if not message["text"][11:].strip().isdigit():
        await message.reply(f"<b>{message.from_user.first_name}, –±—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–∞—Å–∫—É</b>")
        return
    
    if int(message["text"][11:]) > len(tasks):
        await message.reply(f"<b>{message.from_user.first_name}, —Ç–∞—Å–∫—É –ø—ñ–¥ –Ω–æ–º–µ—Ä–æ–º, —è–∫–∏–π –≤–∏ –≤–≤–µ–ª–∏, –Ω–µ –¥—ñ–π—Å–Ω–∏–π</b>")
        return
    
    result = student.delete_task_from_list(user_id, int(message["text"][11:]) - 1)
    
    
    tasks = student.get_tasks(user_id)
    
    tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)])

    if len(tasks) >= 1:
        await message.reply(f"<b>–¢–∞—Å–∫ –ª—ñ—Å—Ç –±—É–ª–æ —É—Å–ø—ñ—à–Ω–æ –∑–º—ñ–Ω–µ–Ω–æ:\n{tasks_text}</b>")
    elif len(tasks) == 0:
        await message.reply(f"<b>–¢–∞—Å–∫ –ª—ñ—Å—Ç –±—É–ª–æ —É—Å–ø—ñ—à–Ω–æ –∑–º—ñ–Ω–µ–Ω–æ.\n–í –Ω—å–æ–º—É –Ω–µ –∑–∞–ª–∏—à–∏–ª–æ—Å—å –¥–∞–Ω–∏—Ö.</b>")


@dp.message_handler(commands=['dell_task'])
async def dell_task(message: types.Message):
    """
    This function handles the '/dell_task' command. It asks the user for confirmation to delete task data.

    Args:
        - message: The message object (doesn't need to contain user input).

    Result:
        - The function asks the user for confirmation to delete task data and sends a response message with a confirmation keyboard.
    """
    user_id = message.from_user.id
    await message.reply(f"<b>{message.from_user.first_name}, –í–∏ —Ç–æ—á–Ω–æ –±–∞–∂–∞—î—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ –¥–∞–Ω—ñ —Ç–∞—Å–∫—ñ–≤?</b>", reply_markup=keyboard_four)



"""                                                              """
"""                Get group name of telegram user               """

@dp.message_handler(commands=['my_group'])
async def my_group(message: types.Message, state: FSMContext):
    """
    This function handles the '/my_group' command. It allows the user to specify their group.

    Args:
        message: The message object containing the user's input.
        state: The FSM context to track the conversation state.

    Returns:
        None
    """
    user_id = message.from_user.id
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)

    if student.check_group_for_user(message.from_user.id):
        await bot.send_message(message.chat.id, f"<b>–í–∏ –≤–∂–µ –≤–∫–∞–∑–∞–ª–∏ —Å–≤–æ—é –≥—Ä—É–ø—É</b>")
        return
    if len(message["text"]) <= 9:
        await bot.send_message(message.chat.id, f"<b>–ü—ñ—Å–ª—è /my_group –Ω–∞–ø–∏—à—ñ—Ç—å –Ω–∞–∑–≤—É —Å–≤–æ—î—ó –≥—Ä—É–ø–∏</b>")
        return
   

    
    group_message_main = message["text"].replace(" ", "").replace("\t", "").replace("\n", "")
    group_message = group_message_main[9:12]
    group_all_message = group_message_main[9:]
 
    if group_message.isdigit():
        
        match = process.extractOne(group_all_message, config.available_groups, score_cutoff=85)
       
        if match is not None:
           
            await bot.send_message(message.chat.id, f"–ó–±—ñ–≥ –±—É–≤ –∑–Ω–∞–π–¥–µ–Ω: <b>{match[0]}.</b>\n–ß–∏ –≤—ñ—Ä–Ω–æ –≤–æ–Ω–æ?", reply_markup=keyboard)
            
        else: 
            
            result_groups = "\n".join(config.available_groups)
            await bot.send_message(message.chat.id, f"<b>–î–ª—è –≤–∞—à–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É <i>{group_all_message}</i> –Ω–µ –±—É–ª–æ –∑–Ω–∞–π–¥–µ–Ω–æ –∑–±—ñ–≥—ñ–≤\n–¥–æ—Å—Ç—É–ø–Ω—ñ –≥—Ä—É–ø–∏ –¥–ª—è —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—ó:</b><b>{result_groups}</b>")
    else:
        await bot.send_message(message.chat.id, f"<b>–ù–∞–∑–≤–∞ –≥—Ä—É–ø–∏ –ø–æ–≤–∏–Ω–Ω–∞ –ø–æ—á–∏–Ω–∞—Ç–∏—Å—è –∑ 3 —Ü–∏—Ñ—Ä, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥:\n422\n422—á</b>")







"""                                                 """
"""                                                 """
"""                                                 """
"""               AI functions                      """
"""                                                 """
"""                                                 """
"""                                                 """
"""                                                 """




"""                                                 """
"""    Openai answers based on chatgpt neural net   """
"""                                                 """

@dp.message_handler(commands=['iso'])
async def handle_info_command_iso(message: types.Message):
    """
    This function handles the '/iso' command and generates a response using the OpenAI ChatGPT model.

    Args:
        message: The message object that triggered the command.

    Result:
        Sends a response generated by the ChatGPT model to the user.
    """

    user_id = message.from_user.id
    print(f"user id - {user_id} - name {message.from_user.first_name}")
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    student.select_username_and_group_name(user_id)
    
    if student.ai_check(user_id) == False and student.check_api_key(user_id) == False:
        await message.reply("<b>–ü—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω—è, –≤–∏ –≤–∏—á–µ—Ä–ø–∞–ª–∏ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑–∞–ø–∏—Ç—ñ–≤ –¥–æ —Å–µ—Ä–≤–µ—Ä—É OpenAI.\n–©–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ Chatgpt, –≤–∏–∫–æ–Ω–∞–π—Ç–∏ —Ü—ñ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó:\n\n1. –ó–∞–π–¥—ñ—Ç—å –Ω–∞ —Ü–µ–π —Å–∞–π—Ç: https://platform.openai.com/account/api-keys\n2. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É, —è–∫–∞ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –ø–æ—Å–µ—Ä–µ–¥–∏–Ω—ñ '+ Create new secret key', —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ api key.\n–î–∞–ª—ñ –≤–≤–µ–¥—ñ—Ç—å –∫–æ–º–∞–Ω–¥—É:\n/api —Ç–∞ —Å–≤—ñ–π –∫–ª—é—á.</b>")
        return
    print("---")
    print(student.ai_check(user_id) )
    print(student.check_api_key(user_id) )
    if student.check_api_key(user_id) == False:
        print("one")
        api_key = config.OpenAIKey

    else:
        print("two")
        api_key = student.get_decrypted_api_key(user_id)
    
    aichat = OpenAiChatHistory()
    chat_history = aichat.get_chat_history(user_id)
    
    try:
        if message.chat.type == types.ChatType.PRIVATE:
            gpt_response, updated_chat_history = await bot_utils.AI_response(message["text"], chat_history,message.from_user.first_name, api_key)
        else:
            gpt_response, updated_chat_history = await bot_utils.AI_response(message["text"][4:], chat_history,message.from_user.first_name, api_key)

        aichat.add_message(user_id, updated_chat_history)
        await message.reply(html.escape(gpt_response))
        student.use_ai(user_id)
    except openai.error.RateLimitError as e:
        await message.reply("<b>–ü–µ—Ä–µ–≤–∏—â–µ–Ω–Ω—è –ª—ñ–º—ñ—Ç—É –∑–∞–ø–∏—Ç—ñ–≤, –±—É–¥—å –ª–∞—Å–∫–∞, –ø–æ—á–µ–∫–∞–π—Ç–µ</b>")
        return
    except openai.error.AuthenticationError:
        await message.reply("<b>–í–∏ –≤–≤–µ–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π api-key, –±—É–¥—å –ª–∞—Å–∫–∞, –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ –Ω–∞ –∫–æ—Ä–µ–∫—Ç–Ω—ñ—Å—Ç—å.\n–©–æ–± –π–æ–≥–æ –∑–º—ñ–Ω–∏—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å –∫–æ–º–∞–Ω–¥—É:\n/new_api —Ç–∞ —Å–≤—ñ–π –Ω–æ–≤–∏–π api-key</b>")
        return
    except exceptions.CantParseEntities:
        await message.reply("<b>–ü—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω—è, –ø–æ–º–∏–ª–∫–∞ –≤ –∑–∞–ø–∏—Ç—ñ –¥–æ —Å–µ—Ä–≤–µ—Ä—É</b>")
        return
    


@dp.message_handler(commands=['api'])
async def handle_info_command_api(message: types.Message):
    """
    This function handles the '/api' command and allows the user to input their OpenAI API key.

    Args:
        message: The message object that triggered the command.

    Result:
        Saves the user's API key and provides a success message.
    """
    user_id = message.from_user.id
    print(f"user id - {user_id} - name {message.from_user.first_name}")
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    student.select_username_and_group_name(user_id) 

    if student.check_api_key(user_id) == True:
        await message.reply("<b>–í–∏ –≤–∂–µ –≤–≤–µ–ª–∏ api-key, —â–æ–± –π–æ–≥–æ –∑–º—ñ–Ω–∏—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å –∫–æ–º–∞–Ω–¥—É:\n/new_api ...</b>")
        return
    if len(message["text"]) <= 4:
        await message.reply("<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /api –≤–≤–µ–¥—ñ—Ç—å —Å–≤—ñ–π api –∫–ª—é—á OpenAi.\n–©–æ–± –π–æ–≥–æ –æ—Ç—Ä–∏–º–∞—Ç–∏:\n\n1. –ó–∞–π–¥—ñ—Ç—å –Ω–∞ —Ü–µ–π —Å–∞–π—Ç: https://platform.openai.com/account/api-keys\n2. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É, —è–∫–∞ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –ø–æ—Å–µ—Ä–µ–¥–∏–Ω—ñ '+ Create new secret key', —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ api key.</b>")
        return
    
    api_key = message["text"][4:]
    api_key = message["text"][4:].replace('"', '').replace("'", '')
   
    
    try:
        student.insert_api_key(user_id, api_key)
        await message.reply("<b>‚úÖ –û–ø–µ—Ä–∞—Ü—ñ—è —É—Å–ø—ñ—à–Ω–∞, —Ç–µ–ø–µ—Ä –º–æ–∂–µ—Ç–µ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—è —Ñ—É–Ω–∫—Ü—ñ—î—é /iso</b>")
    except Exception as e:
        print(e)
        await message.reply("<b>–ü—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω–Ω—è, –≤–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞</b>")

@dp.message_handler(commands=['new_api'])
async def handle_info_command_new_api(message: types.Message):
    """
    This function handles the '/new_api' command and allows the user to update their OpenAI API key.

    Args:
        message: The message object that triggered the command.

    Result:
        Updates the user's API key and provides a success message.
    """
    user_id = message.from_user.id
    print(f"user id - {user_id} - name {message.from_user.first_name}")
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    student.select_username_and_group_name(user_id) 

    if len(message["text"]) <= 8:
        await message.reply("<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /new_api –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–≤–∏–π api-key.</b>")
        return
    new_api_key = message["text"][9:]
    new_api_key = message["text"][9:].replace('"', '').replace("'", '')
   
    try:
        student.insert_api_key(user_id, new_api_key)
        await message.reply("<b>‚úÖ –û–ø–µ—Ä–∞—Ü—ñ—è —É—Å–ø—ñ—à–Ω–∞, –≤–∞—à api-key –±—É–ª–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ</b>")
    except Exception as e:
        print(e)
        await message.reply("<b>–ü—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω–Ω—è, –≤–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞</b>")




"""                                                                 """
"""  Generate Image, using Openai neural network DALL-E API         """
"""                                                                 """
@dp.message_handler(commands=['generate_image'])
async def generate_command_handler(message: Message):
    try:
        
        if len(message["text"]) == 15:
            await message.reply("–ü—ñ—Å–ª—è /generate_image –≤–≤–µ–¥—ñ—Ç—å –æ–ø–∏—Å")
            return 
        
        description = message["text"][15:].strip()
        loop = asyncio.get_event_loop()

        # Get a link to the image in a separate thread 
        image_url = await loop.run_in_executor(None, bot_utils.generate_image, description)

        # Download image
        image_data = requests.get(image_url).content

        # Send image to user
        await bot.send_photo(chat_id=message.chat.id, photo=image_data)
    except Exception as e:

        # If an error occurs, send it to the user
        error_message = str(e)
        if "Your request was rejected" in error_message:
            error_message = "–í–∞—à –∑–∞–ø–∏—Ç –±—É–ª–æ –≤—ñ–¥—Ö–∏–ª–µ–Ω–æ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞–º–∏ –±–µ–∑–ø–µ–∫–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –∑–º—ñ–Ω–∏—Ç–∏ –æ–ø–∏—Å –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è."
            await message.reply(error_message)



    
"""                                                                                 """
"""                     Removing background from Image                              """
"""                                                                                 """

class PhotoProcessingState:
    def __init__(self):
        self.processing_photo = False

photo_processing_state = PhotoProcessingState()

@dp.message_handler(Command('remove_background'))
async def remove_background_command(message: types.Message, state: FSMContext):
    # Giving user info
    await message.reply("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è –æ–±—Ä–æ–±–∫–∏.")
    
    # Set the processing state for the current user
    await state.set_state('processing_photo')
    photo_processing_state.processing_photo = True

@dp.message_handler(content_types=types.ContentTypes.PHOTO, state='processing_photo')
async def process_photo(message: types.Message, state: FSMContext):
    # Taking photo file
    photo = message.photo[-1]
    # Getting file info
    file_info = await bot.get_file(photo.file_id)
    file_path = file_info.file_path

    # Downloading photo file 
    downloaded_photo = await bot.download_file(file_path)

    # Create a temporary file for processing
    photo_path = "photo.png"
    with open(photo_path, "wb") as file:
        file.write(downloaded_photo.getvalue())

    # Processing the photo
    processed_photo_path = "processed_photo.png"
    bot_utils.backGroundRemove(photo_path, processed_photo_path)

    # Send the processed photo to the user
    with open(processed_photo_path, "rb") as file:
        await bot.send_photo(message.chat.id, InputFile(file))

    # Delete temporary files
    os.remove(photo_path)
    os.remove(processed_photo_path)

    # Reset the processing state for the current user
    await state.finish()
    photo_processing_state.processing_photo = False




"""                                                 """
"""                 Image to text                   """
"""                                                 """

class OCRState(StatesGroup):
    waiting_for_photo = State()

class UkOCRState(StatesGroup):
    waiting_for_photo = State()


@dp.message_handler(commands=['uk_ocr'])
async def uk_ocr_command_handler(message: types.Message):
    """
    This function handles the '/uk_ocr' command and requests the user to send a photo for text recognition.

    Args:
        message: The message object that triggered the command.
    """
    # Sending a message with a request to send a photo
    await message.reply("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Ç–µ–∫—Å—Ç—É.")

    # Set photo standby state
    await UkOCRState.waiting_for_photo.set()


@dp.message_handler(content_types=types.ContentTypes.PHOTO, state=UkOCRState.waiting_for_photo)
async def photo_received_handler(message: types.Message, state: FSMContext):
    """
    This function handles the photo received in response to the '/uk_ocr' command and performs text recognition in ukrainian languages.

    Args:
        message: The message object that contains the received photo. 
        state: The FSMContext object for managing the state of the conversation.

    Result:
        Sends the recognized text from the photo to the user.
    """
    # Get photo id
    photo_id = message.photo[-1].file_id

    # –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
    photo = await bot.get_file(photo_id)
    photo_path = photo.file_path

    # Save the photo to the "photos" directory with a unique name
    save_path = os.path.join('photos', f'photo_{photo_id}.jpg')
    await photo.download(save_path)

    # Text recognising
    try:
        text = bot_utils.uk_image_to_text(save_path)
    except:
        await message.reply(f"<b>–ü—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω–Ω—è, –≤–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞.</b>")
        return
    # Send the recognized text to the user
    await message.reply(text)

    # Deleting a saved photo
    os.remove(f"photos_{photo_id}.jpg")

    # –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è
    await state.finish()


@dp.message_handler(commands=['ocr'])
async def ocr_command_handler(message: types.Message):
    """
    This function handles the '/ocr' command and requests the user to send a photo for text recognition in english, deutsch, french languages.

    Args:
        message: The message object that triggered the command.
    """
    # Sending a message with a request to send a photo
    await message.reply(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Ç–µ–∫—Å—Ç—É.</b>")

    # Set photo standby state
    await OCRState.waiting_for_photo.set()


@dp.message_handler(content_types=types.ContentTypes.PHOTO, state=OCRState.waiting_for_photo)
async def photo_received_handler(message: types.Message, state: FSMContext):
    """
    This function handles the photo received in response to the '/ocr' command and performs text recognition.

    Args:
        message: The message object that contains the received photo.
        state: The FSMContext object for managing the state of the conversation.

    Result:
        Sends the recognized text from the photo to the user.
    """
    # Get photo id
    photo_id = message.photo[-1].file_id

  
    photo = await bot.get_file(photo_id)
    photo_path = photo.file_path

    
    save_path = os.path.join('photos', f'photo_{photo_id}.jpg')
    await photo.download(save_path)

    
    try:
        text = bot_utils.image_to_text(save_path)
        print(text)
    except Exception as e:
        await message.reply(f"<b>–ü—Ä–æ—à—É –≤–∏–±–∞—á–µ–Ω–Ω—è, –≤–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞.</b>")
        return

    escaped_text = html.escape(text)
    await message.reply(escaped_text)

   
    os.remove(f"photos_{photo_id}.jpg")

    await state.finish()




"""                                           """
"""                Speech to text             """
"""                                           """

# Convert the file from ogg to wav
def convert_audio(file_path, file_name):
    """
    This function converts the audio file from ogg format to wav format.
    Args:
        file_path (str): The path of the input audio file.
        file_name (str): The name of the output audio file.
    Result:
        None
    """

    subprocess.call([config.ffmpeg_path, '-i', file_path, '-ar', '48000', file_name])


@dp.message_handler(content_types=[
    types.ContentType.VOICE,
    types.ContentType.AUDIO
    ]
)
async def voice_message_handler(message: types.Message):
    """
    This function is the handler for processing voice and audio messages.
    Args:
        message (types.Message): The message object containing the voice or audio data.
    Result:
        Send user transcription of the voice file.
    """
    if message.chat.id == -1001669920130:
        return
    user_id = message.from_user.id
 
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    
    if message.content_type == types.ContentType.VOICE:
        file_id = message.voice.file_id
    elif message.content_type == types.ContentType.AUDIO:
        file_id = message.audio.file_id
    elif message.content_type == types.ContentType.DOCUMENT:
        file_id = message.document.file_id
    else:
        await message.reply("–§–æ—Ä–º–∞—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è")
        return

    file = await bot.get_file(file_id)
    file_path = file.file_path
    file_on_disk = Path("", f"{file_id}.tmp")
    await bot.download_file(file_path, destination=file_on_disk)
    
   
    text = stt_rec.audio_to_text(file_on_disk)
    if not text:
        text = "–§–æ—Ä–º–∞—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"
    await message.reply(text)

    os.remove(file_on_disk) 





"""                                               """
"""                                               """
"""                                               """
"""               Other functions                 """
"""                                               """
"""                                               """
"""                                               """

@dp.message_handler(commands=['chat_id'])
async def chat_id_handler(message: types.Message):
    chat_id = message.chat.id
    await message.reply(f'Chat ID: <code>{chat_id}</code>', parse_mode=ParseMode.HTML)


"""                                               """
"""                Get Weather                    """
"""                                               """

@dp.message_handler(commands=['weather'])
async def weather_info(message: types.Message, user_id: int = None):
    """
    This function handles the '/weather' command to retrieve weather information for a specific city.
    Args:
        weather [place]: The name of the city for which weather information is requested.

    Result:
        None
    """
    if message is not None and message.from_user is not None:
        user_id = message.from_user.id
        student.update_username(user_id, message.from_user.first_name)
        student.add_user(user_id, message.from_user.first_name)
    else:
        user_id = None
  
 
    try:
        if len(message.text) <=8:
            await message.reply("–ü—ñ—Å–ª—è /weather –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –º—ñ—Å—Ç–∞\n–ù–∞–ø—Ä–∏–∫–ª–∞–¥: \n/weather –ö–∏—ó–≤ ")
        else:   
            weather_info, temperature = bot_utils.get_weather(message.text[8:])
            weather_info = escape(weather_info)

            await message.reply(weather_info,  parse_mode=ParseMode.MARKDOWN_V2, )
            if temperature > 12:
                photo_path = open('photos/sun.png', 'rb')
            else:
                photo_path = open('photos/cold.png', 'rb')
            await bot.send_photo(chat_id=message.chat.id, photo=photo_path)
    except Exception as e:
      print(f"–ü–æ–º–∏–ª–∫–∞: {e}")


"""                                                 """
"""         Latest info using parsing               """
"""                                                 """
@dp.message_handler(commands=['info'])
async def handle_info_command_info(message: types.Message):
    """
    This function handles the '/info' command and provides information based on the user's query.

    Args:
        message: The message object that triggered the command.

    Result:
        Sends relevant information or news based on the user's query, or general news if no specific query is provided.
    """
    user_id = message.from_user.id
 
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    if len(message["text"]) <= 5:
        await message.reply(f"<b>–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /info –≤–≤–µ–¥—ñ—Ç—å –≤–∞—à –∑–∞–ø–∏—Ç, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥:\n/info –ó–°–£</b>")
        return
    try:
        news = bot_utils.newsInfo(message["text"][6:])
        if news is None:
            news_else = bot_utils.data_parser("https://www.unian.ua/") 
            news_else_str = "".join(news_else)
            await message.reply(f"<b>–ù–∞ –≤–∞—à –∑–∞–ø–∏—Ç –Ω–µ –±—É–ª–æ –∑–Ω–∞–π–¥–µ–Ω–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó.\n\n–û—Å—å –≥–æ–ª–æ–≤–Ω—ñ –ø–æ–¥—ñ—ó –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –¥–µ–Ω—å:\n{news_else_str}</b>")
            return
        news_main = "\n\n".join(news)
        await message.reply(f"<b>{news_main}</b>")
        return
    except exceptions.MessageTextIsEmpty:
        await message.reply(f"<b>–î–∞–Ω–∏—Ö –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ –Ω–µ–º–∞—î.</b>")


"""                                                 """
"""             Resources parsing                    """
"""                                                 """
@dp.message_handler(commands=['resources'])
async def handle_info_command_api(message: types.Message):
    """
    This function handles the '/resources' command and provides learning resources based on the user's query.

    Args:
        message: The message object that triggered the command.

    Result:
        Sends a list of learning resources and a PDF file related to the user's query, if available.
    """
    user_id = message.from_user.id
    print(f"user id - {user_id} - name {message.from_user.first_name}")
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    student.select_username_and_group_name(user_id) 
    if len(message["text"]) <= 10:
        await message.reply("<b>–ü—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /resources –≤–≤–µ–¥—ñ—Ç—å –∑–∞–ø–∏—Ç.</b>")
        return
    
    links = bot_utils.learning_resources_links(message["text"][11:])
    links_str = "\n\n".join(links)
    if len(links) > 0:
        await message.reply(f"<b>–í–∞—à—ñ —Å—Å–∏–ª–∫–∏ –Ω–∞ —Ä–µ—Å—É—Ä—Å–∏:\n{links_str}</b>")
        with tempfile.TemporaryDirectory() as temp_dir:
           
            bot_utils.search_pdf(message["text"][11:])
            
            with open("pdf_file.pdf", "rb") as file:
                await message.answer_document(file)
            
     
    else:
        await message.reply("<b>–ü–æ –≤–∞—à–æ–º—É –∑–∞–ø–∏—Ç—É –Ω–µ–º–∞—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó</b>")

    
@dp.message_handler(commands=['ping_all'])
async def ping_all(message: types.Message):

    if message.chat.id != -1001669920130:
        await bot.send_message(message.chat.id, f"<b>–î–æ—Å—Ç—É–ø –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ</b>")
        return
    
    
    for member in config.user_mentions:  
        await bot.send_message(message.chat.id, f'Ping! {member}', reply_to_message_id=message.message_id)
    
    await bot.send_message(message.chat.id, f"<b>https://teams.microsoft.com/_#/calendarv2</b>")




"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""              Callback handler commands -> Buttons               """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """



"""                             """

"""      Commands buttons       """

"""                             """
BTN_WEATHER = InlineKeyboardButton('Weather', callback_data='weather')
BTN_ISO = InlineKeyboardButton('—à—Ç—É—á–Ω–∏–π —ñ–Ω—Ç–µ–ª–ª–µ–∫—Ç', callback_data='iso')
BTN_INFO = InlineKeyboardButton('–ø–æ—Ç–æ—á–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è', callback_data='info')
BTN_SCH = InlineKeyboardButton('—Ä–æ–∑–∫–ª–∞–¥', callback_data='schedule_day')
BTN_GROUP = InlineKeyboardButton('–º–æ—è –≥—Ä—É–ø–∞', callback_data='my_group')
BTN_NEW_SCH = InlineKeyboardButton('–Ω–æ–≤–∏–π —Ä–æ–∑–∫–ª–∞–¥', callback_data='new_schedule')
BTN_Task_Add = InlineKeyboardButton('–Ω–æ–≤–∏–π —Ç–∞—Å–∫', callback_data='new_task_help')
BTN_Task_Info = InlineKeyboardButton('task info', callback_data='task_info_help')
BTN_Doc = InlineKeyboardButton('doc create', callback_data='doc_creating')
HELP = InlineKeyboardMarkup().add(BTN_ISO, BTN_SCH, BTN_NEW_SCH,BTN_GROUP,BTN_Task_Add, BTN_Task_Info, BTN_Doc,  BTN_WEATHER, BTN_INFO)


"""User input buttons"""
keyboard = InlineKeyboardMarkup()
yes_button = InlineKeyboardButton(text="–¢–∞–∫", callback_data="group_confirm")
no_button = InlineKeyboardButton(text="–ù—ñ", callback_data="group_cancel")
keyboard.add(yes_button, no_button)

keyboard_second = InlineKeyboardMarkup()
yes_button_second = InlineKeyboardButton(text="–û–±–Ω–æ–≤–∏—Ç–∏", callback_data="update_confirm")
no_button_second = InlineKeyboardButton(text="–í—ñ–¥–º—ñ–Ω–∞", callback_data="update_cancel")
keyboard_second.add(yes_button_second, no_button_second)

keyboard_third = InlineKeyboardMarkup()
yes_button_third = InlineKeyboardButton(text="–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂—É—é", callback_data="schedule_confirm")
no_button_third = InlineKeyboardButton(text="–í—ñ–¥–º—ñ–Ω–∞", callback_data="schedule_cancel")
keyboard_third.add(yes_button_third, no_button_third)


keyboard_four = InlineKeyboardMarkup()
yes_button_four = InlineKeyboardButton(text="–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂—É—é", callback_data="taskDellConfirm")
no_button_four = InlineKeyboardButton(text="–í—ñ–¥–º—ñ–Ω–∞", callback_data="taskDellDecline")
keyboard_four.add(yes_button_four, no_button_four)


keyboard_five = InlineKeyboardMarkup()
yes_button_five = InlineKeyboardButton(text="–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂—É—é", callback_data="wordsDeleteAccept")
no_button_five = InlineKeyboardButton(text="–í—ñ–¥–º—ñ–Ω–∞", callback_data="wordsDeleteDecline")
keyboard_five.add(yes_button_five, no_button_five)






"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                 Callback handler commands                       """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """

@dp.callback_query_handler(lambda c: c.data == 'weather')
async def process_callback_weather(callback_query: types.CallbackQuery):
    """ This function handles info about  /weather command. It sends a message explaining how to use the command."""

    await bot.answer_callback_query(callback_query.id)

    user_id = callback_query.from_user.id
    message_text = f'/weather –ö–∏—ó–≤'  # The default value is "/weather –ö–∏—ó–≤"
    message = types.Message(text=message_text, chat=callback_query.message.chat, from_user=callback_query.from_user)
    
    await weather_info(message, user_id)
 

"""                                                                                  """
"""                Button functions, to show how to use iso command (Chatgpt  AI)     """

@dp.callback_query_handler(lambda c: c.data == 'iso')
async def process_callback_ai(callback_query: types.CallbackQuery):
    """ This function handles info about  /iso command. It sends a message explaining how to use the command."""

    await bot.answer_callback_query(callback_query.id)
    user_id = callback_query.from_user.id
    await bot.send_message(callback_query.message.chat.id, f"<b>–í–∏ –º–æ–∂–µ—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç–∏ /iso '–∑–∞–ø–∏—Ç'\n–∑–∞–¥–ª—è –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ —à—Ç—É—á–Ω–æ–≥–æ —ñ–Ω—Ç–µ–ª–ª–µ–∫—Ç—É –Ω–∞ –≤–∞—à –∑–∞–ø–∏—Ç</b>")
   
"""                                                                      """
"""                Button functions, to show how to use info command     """
@dp.callback_query_handler(lambda c: c.data == 'info')
async def process_callback_info(callback_query: types.CallbackQuery):
    """ This function handles info about  /info command. It sends a message explaining how to use the command."""

    await bot.answer_callback_query(callback_query.id)
    await handle_info_command_info(callback_query.message)  # –ü–µ—Ä–µ–¥–∞–µ–º callback_query.message –Ω–∞–ø—Ä—è–º—É—é



"""                                                                              """
"""                Button functions, to show how to use schedule_day command     """

@dp.callback_query_handler(lambda c: c.data == 'schedule_day')
async def process_callback_schedule_day(callback_query: types.CallbackQuery):
    """ This function handles info about  /schedule_day command. It sends a message explaining how to use the command."""

    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>–í–∏ –º–æ–∂–µ—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç–∏:\n<i>/schedule_day –Ω–∞–∑–≤–∞ –≥—Ä—É–ø–∏, –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ</i>\n–∑–∞–¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–æ–∑–∫–ª–∞–¥—É</b>")


"""                                                                              """
"""                Button functions, to show how to use new_schedule command     """

@dp.callback_query_handler(lambda c: c.data == 'new_schedule')
async def process_callback_new_schedule(callback_query: types.CallbackQuery):
    """ This function handles info about  /new_schedule command. It sends a message explaining how to use the command."""
    
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>–ù–∞–ø–∏—à—ñ—Ç—å –Ω–∞–∑–≤—É –≥—Ä—É–ø–∏, –¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ, –Ω–∞–∑–≤—É –ø—Ä–µ–¥–º–µ—Ç–∞, —á–∞—Å —É —Ñ–æ—Ä–º–∞—Ç—ñ –≥–æ–¥–∏–Ω–∞:—Ö–≤–∏–ª–∏–Ω–∞ (16:30)</b>\n–©–æ–± –≤—Å–µ –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–æ–±–∏—Ç–∏, –¥–∞–Ω—ñ –ø–∏—à—ñ—Ç—å —á–µ—Ä–µ–∑ –∫–æ–º—É, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥:\n/new_schedule <b>'422', –ü–æ–Ω–µ–¥—ñ–ª–æ–∫, –≤–∏—â–∞ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞, 18:00</b>")




"""                                                                              """
"""                Button functions, to show how to use my_group command         """


@dp.callback_query_handler(lambda c: c.data == 'my_group')
async def process_callback_new_group(callback_query: types.CallbackQuery):
    """ This function provides information about  /my_group command. It sends a message explaining how to use the command. """
    
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>–ü—ñ—Å–ª—è /my_group –Ω–∞–ø–∏—à—ñ—Ç—å –Ω–∞–∑–≤—É —Å–≤–æ—î—ó –≥—Ä—É–ø–∏</b>")
    

"""                                                                                      """
"""                Button functions, to confirm initializing group name, or decline      """

@dp.callback_query_handler(lambda c: c.data == 'group_confirm')
async def process_callback_group_confirm(callback_query: types.CallbackQuery):
    """ This function handles the callback when the group name setting is confirm. """
    
    await bot.answer_callback_query(callback_query.id)
    text = callback_query.message["text"]
    number_group = text.split(": ")[1].split(".")[0]
   
    if number_group:
        group_name = number_group
        
        if group_name in config.available_groups:
            user_id = callback_query.from_user.id
            student.add_user_with_group(user_id, group_name)
            await bot.send_message(callback_query.message.chat.id, f"<b>\U00002705 –í—ñ—Ç–∞—é, {student.select_username_and_group_name(user_id)}, –≤–∞—à–∞ –Ω–∞–∑–≤–∞ –≥—Ä—É–ø–∏ –±—É–ª–∞ –∑–∞–ø–∏—Å–∞–Ω–∞ —É –±–∞–∑—É –¥–∞–Ω–∏—Ö, —Ç–µ–ø–µ—Ä –≤–∏ –º–æ–∂–µ—Ç–µ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—è —Ñ—É–Ω—Ü—ñ—è–º–∏:\n/schedule_day\n/new_schedule\n</b>")


@dp.callback_query_handler(lambda c: c.data == 'group_cancel')
async def process_callback_group_cancel(callback_query: types.CallbackQuery):
    """ This function handles the callback when the group name setting is cancel. """
    
    await bot.answer_callback_query(callback_query.id, "Settings group name")
    await bot.send_message(callback_query.message.chat.id, f"<b>–í—ñ–¥–º—ñ–Ω–∞ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –≥—Ä—É–ø–∏</b>")



"""                                                                                """
"""                Button functions, to confirm schedule, or decline               """

@dp.callback_query_handler(lambda c: c.data == 'schedule_confirm')
async def process_callback_schedule_confirm(callback_query: types.CallbackQuery):
    """ This function handles the callback when the schedule adding is confirm. """
    text = callback_query.message["text"]   

    lines = text.splitlines()  # Split text into lines

    for line in lines:
        if "–Ü–º'—è –≥—Ä—É–ø–∏" in line:
            group_name = line.split("-")[1].strip()  # Get value after "-"
        elif "–¥–µ–Ω—å –Ω–µ–¥—ñ–ª—ñ" in line:
            day_of_week = line.split("-")[1].strip()  # Get value after "-"
        elif "–ù–∞–∑–≤–∞ –ø—Ä–µ–¥–º–µ—Ç—É" in line:
            subject = line.split("-")[1].strip()
        elif "–ü–æ—á–∞—Ç–æ–∫" in line:
            start_time = line.split("-")[1].strip()  # Get value after "-"
        
  
    num_week = 1
    # Get the updated schedule for the day after adding the subject
    schedule_of_day = scheduleTable.get_subject_by_day_and_time(group_name, day_of_week, start_time, num_week)
    
    await bot.send_message(callback_query.message.chat.id, f"<b>\U00002705 –ü—Ä–µ–¥–º–µ—Ç –±—É–ª–æ —É—Å–ø—ñ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ —É –≤–∞—à —Ä–æ–∑–∫–ª–∞–¥</b>")
    await bot.answer_callback_query(callback_query.id, "schedule updating confirm!")
    
    scheduleTable.insert_test(group_name, day_of_week, subject, start_time, num_week=1)
    # Update the message with the new schedule day
    callback_query.message.text = f"/schedule_day {callback_query.message.text[30:38]}"
    await callback_query.message.edit_text(text=callback_query.message.text)
    await schedule_day(callback_query.message, day_of_week)

@dp.callback_query_handler(lambda c: c.data == 'schedule_cancel')
async def process_callback_schedule_cancel(callback_query: types.CallbackQuery):
    """ This function handles the callback when the schedule adding is canceled. """

    await bot.answer_callback_query(callback_query.id, "Schedule updating cancel!")
    await bot.send_message(callback_query.message.chat.id, f"<b>–ó–º—ñ–Ω–∏ –≤—ñ–¥—Ö–∏–ª–∏–Ω—ñ!</b>")
    


"""      processing user actions, using button data -> confim or decline deletting task     """
"""                                                                                         """

@dp.callback_query_handler(lambda c: c.data == 'taskDellConfirm')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """ This function handles the callback when the task delete is confirmed. It sends a confirmation message and then deletes the task """
    
    await bot.answer_callback_query(callback_query.id, "Delete confirm")
    await bot.send_message(callback_query.message.chat.id, f"<b>Delete confirm</b>")
 
    user_id = callback_query.from_user.id
    student.delete_task(user_id)
  

@dp.callback_query_handler(lambda c: c.data == 'taskDellDecline')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """This function handles the callback when the task delete is declined. It sends a decline message."""
    
    await bot.answer_callback_query(callback_query.id, "Delete decline")
    await bot.send_message(callback_query.message.chat.id, f"<b>Delete decline</b>")


"""      Info about command /new_task        """
@dp.callback_query_handler(lambda c: c.data == 'new_task_help')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """ This function provides information about the /new_task command. It sends a message explaining how to use the command. """
   
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>–ü—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏: /new_task –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ —Ç–∞—Å–∫—É.</b>")

"""      Info about command /task_list        """
@dp.callback_query_handler(lambda c: c.data == 'task_info_help')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """ This function provides information about the /task_list command. It sends a message explaining how to use the command. """

    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>–í–≤–µ–¥—ñ—Ç—å –∫–æ–º–∞–Ω–¥—É /task_list, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –∞–∫—Ç–∏–≤–Ω—ñ —Ç–∞—Å–∫–∏</b>")
    print(callback_query.message)
    
   


"""      Info about command /doc        """
@dp.callback_query_handler(lambda c: c.data == 'doc_creating')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """  This function provides information about the /doc command. It sends a message explaining how to use the command. """
   
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>–ü—ñ—Å–ª—è –∫–æ–º–∞–Ω–¥–∏ /doc –Ω–∞–ø–∏—à—ñ—Ç—å:\n–ù–∞–∑–≤—É –¥–∏—Å—Ü–∏–ø–ª—ñ–Ω–∏, –Ω–∞–∑–≤—É –≥—Ä—É–ø–∏, —ñ–º'—è —Å—Ç—É–¥–µ–Ω—Ç–∞, —ñ–º'—è –≤—á–∏—Ç–µ–ª—è\n–©–æ–± –≤—Å–µ –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–æ–±–∏—Ç–∏, –Ω–∞–ø—à—ñ—Ç—å –¥–∞–Ω—ñ —á–µ—Ä–µ–∑ –∫–æ–º—É</b>")
    print(callback_query.message)

#keyboard_five

"""      Accept words deleting command /word_done        """
@dp.callback_query_handler(lambda c: c.data == 'wordsDeleteAccept')
async def process_callback_words_delete_accept(callback_query: types.CallbackQuery):
    """  This function delete words from DB.  """

    user_id = callback_query.from_user.id
    print(user_id)
    text = callback_query.message["text"].strip().split(":")
    print(text[1])

    
    test = wordDataBase.get_specific_language_words(user_id, text[1].strip())

    if len(test) == 0:
        await bot.send_message(callback_query.message.chat.id, f"<b>–í–∏ –≤–∂–µ –≤–∏–¥–∞–ª–∏–ª–∏ –¥–∞–Ω—ñ</b>")
        return
    

    wordDataBase.remove_words_by_language(user_id, text[1].strip())

    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"‚úÖ –°–ª–æ–≤–∞ –±—É–ª–∏ –≤–∏–¥–∞–ª–µ–Ω—ñ")
    callback_query.from_user.is_bot = True

    await words_list_callback(callback_query)


@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def handle_info_message_iso_in_private_chat(message: types.Message):
    """
    This function handles incoming text messages in a private chat and processes them as ISO commands.

    Args:
        message: The message object containing the received text.

    Result:
        The message is processed as an ISO command.
    """
    if message.chat.type == types.ChatType.PRIVATE and not message.text.startswith('/'):
        await handle_info_command_iso(message)


dp.register_message_handler(voice_message_handler, content_types=types.ContentType.VOICE)
dp.register_message_handler(check_schedule_for_all_groups, commands="start")
dp.register_message_handler(handle_info_message_iso_in_private_chat, content_types=types.ContentType.TEXT)


if __name__ == '__main__':
    # Create an asyncio event loop
    
    loop = asyncio.get_event_loop()
    
    stt_rec = STT()
    # Run the check_schedule coroutine in the event loop
    loop.create_task(check_schedule_for_all_groups())

    # Start the aiogram executor 
    executor.start_polling(dp)



    