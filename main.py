# -*- coding: utf-8 -*-
"""
This app provides functionality to help students using Telegram Messenger

For the correct processing of data, the DB SQLITE is used, 
    data is entered  and extracted there.

Functionality provided by this program includes:
    - Schedule operations:
        - /schedule: Get the schedule for the current day.
        - /schedule_day [day]: Get the schedule for a specific day of the week.
        - /new_schedule [day] [subject] [time]: Add a new schedule entry for a specific day, subject, and time.

    - Group operations:
        - /my_group: Get the name of your current group.

    - Document operations:
        - /doc [topic] [group] [your_name] [instructor_name]: Create a document with the specified topic, group, your name, and instructor name.
        - /specialDoc  [topic name] -> return .docx file with data, generated by OpenAi ChatGpt, approximate waiting time - 20 seconds.

    - Foreign words operation:
        - /word [Text]: Identify the source language and translate it into Ukrainian. Then add it to the database.
        - /uword [Language to translate] [text in Ukrainian]: Translate the text from Ukrainian to the specified language. Then add it to the database.
        - /word_list: Provide a list of all words that the user has written.
        - /certain_words [Language]: Provide a list of words in the specified language.
        - /word_done [Language], [index]: Mark a word in the specified language and with the given index as completed.
        - /remove_words [Language]: Remove all words in the specified language.

    - Task operations:
        - /new_task [task_description]: Add a new task to your task list.
        - /task_list: Get information about your tasks.
        - /task_done [task_number]: Mark a task as completed.
        - /dell_task [task_number]: Delete a task from your task list.

    - HomeWork Operations:
        - /homeWorkAdd [subject name], [homework:str]: Add user homework to Database
        - /homeWorkInfo [subject name] - get data about user tasks
        - /homeWorkMainInfo - displays all your homework.
        - /homeWorkDell [the name of the item where you want to delete the data]: Delete user homework from certain subject (based on query)
                                                                              
    - AI operations:
        - /iso [query]: Makes a request to the OpenAi server to get a response from the neural network ChatGpt
        - /api [api-key]: accepts from the user OpenAi api-key
        - /new_api [new api-key]  update user OpenAi key in database
        - /generate_image [query]: Generate an image based on the specified query.
        - /remove_background: After this command, send photo, and program return one without background.
        - /uk_ocr - Get text on ukraine or russian language from image
        - /ocr - Get text on  English, deutsch, french language from image

    - Miscellaneous operations:
        - /resources [query]: get links of sites, related to query.
        - /info: Get the latest news information.
        - /weather [city]: Get the weather information for the specified city.
        - Audio file translation: The bot can automatically translate audio files from Ukrainian and russian languages.
"""





""" Standard library imports """
import io
import os
import re
import time
import datetime
import tempfile
import threading
import subprocess
from re import escape

""" Third-party library imports """
import json
import vosk
import wave
import html
import openai
import asyncio
import logging
import requests
import schedule
from fuzzywuzzy import process
from pydub import AudioSegment
from datetime import datetime, timedelta

""" AIogram library imports """
from aiogram import Bot, types
from aiogram.utils import executor
from aiogram.utils import exceptions
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher import Dispatcher
from aiogram.types import Message, ParseMode
from aiogram.utils.exceptions import BadRequest
from aiogram.types import ContentType, InputFile
from aiogram.dispatcher import FSMContext, filters
from aiogram.dispatcher.filters import BoundFilter
from aiogram.dispatcher.filters import Command, BoundFilter
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup


""" Local imports """
import config
import bot_utils
from stt import STT
from pathlib import Path
from students_database import Student, OpenAiChatHistory, ScheduleTable, HomeworkBot, WordDatabase


"""                                           """
"""    Student Database initialization        """
"""                                           """
student = Student()
scheduleTable = ScheduleTable()
homeworkData  = HomeworkBot()
wordDataBase  = WordDatabase()
"""                                           """
"""    Telegram Bot initialization            """
"""                                           """

bot = Bot(token=config.TOKEN, parse_mode=types.ParseMode.HTML)
dp = Dispatcher(bot, storage=MemoryStorage())
# Setting up logging
logging.basicConfig(level=logging.INFO)




"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """

"""                                                                    """
"""                                                                    """
"""                TELEGRAM BOT COMMANDS PROCESSING                    """
"""                                                                    """
"""                                                                    """

"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """
"""                                                                    """





"""                                                                     """
"""     Сalculate which command need user data of university group      """
"""                                                                     """
command_groups = {
    "/help": False, 
    "/new_schedule": True, 
    "/schedule": False,
    "/schedule_day": True,
    
    "/my_group": False,
     

    "/doc": False,
    "/specialDoc": False,

    "/word": False,
    "/word_list": False,
    "/list_word": False,
    "/certain_words": False,
    "/word_done": False,
    "/remove_words": False,

    "/new_task": False, 
    "/task_list": False,
    "/task_done": False,
    "/dell_task": False,

    "/homeWorkAdd": False,
    "/homeWorkInfo": False,
    "/homeWorkDell": False,
    "/homeWorkMainInfo": False,

    "/iso":False,  
    "/api": False, 
    "/new_api":False, #

    "/generate_image": False, 
    "/remove_background": False, 
    "/uk_ocr": False,
    "/ocr": False,

    "/resources": False, 
    "/info": False,
    "/weather":False, 
    "/chat_id": False
}


@dp.message_handler(commands=['start'])
async def send_greeting(message: types.Message, state: FSMContext):
    if message.chat.type == types.ChatType.PRIVATE:
        # If the bot is running in a private chat with the user
       
        await message.answer(f'Привіт, {message.from_user.first_name}!\nЯ - бот для допомоги студентам. Список доступних команд:\n')
        await asyncio.sleep(1)
        await handle_info_command_help(message)
    else:
        # If the bot is running in a channel or group
        await message.answer('Привет, усім!\nЯ - бот для допомоги студентам. Список доступних команд:\n')
        await asyncio.sleep(1)
        await handle_info_command_help(message)




"""                                           """
"""            Info about commands            """
"""                                           """

@dp.message_handler(commands=['help'])
async def handle_info_command_help(message: types.Message):
    """
    This function handles the '/help' command. It provides information about the available commands and their usage.

    Args:
        message: The message object containing the user's input.

    Returns:
        None
    """
    user_id = message.from_user.id
 
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)

    await bot.send_message(message.chat.id, f"<b>Commands:</b>\n\n"
                                            "<b>Розклад</b>:\n"
                                            "/schedule - розклад на сьогоднішній день\n"
                                            "/schedule_day [день неділі]\n"
                                            "/new_schedule [день неділі], [назва предмета], [час у форматі година:хвилина (16:30)]\n"
                                            "/my_group [назва вашої групи]\n\n"
                                            
                                            "<b>Docx файли:</b>"
                                            "\n   /doc [назва теми], [групи], [ваше ім'я], [ім'я Викладача]\n"
                                            "   /specialDoc [назва теми]\n\n"

                                            "<b>Словник:</b>"
                                            "\n   /word - Переводить текст та добавляє його у ваш словник\n"
                                            "   /uword - Переводить текст з української на мову, яку ви вказали, та добавляє його у ваш словник\n"
                                            "   /word_list - Повертає список всіх ваших слів\n"
                                            "   /certain_words - Повертає список слів на указаній мові із вашого словника\n"
                                            "   /remove_words - Видаляє слово\n\n"

                                            "<b>Завдання:</b>"
                                            "\n   /new_task [назва вашого таску]\n"
                                            "   /task_list - отримати дані про ваші таски\n"
                                            "   /task_done [номер таску] - відмічає таск як виконаний\n"
                                            "   /dell_task - видалити ваші таски\n\n"

                                            "<b>HomeWork</b>"
                                            "\n   /homeWorkAdd [назва предмета], [домашнє завдання]\n"
                                            "   /homeWorkInfo [назва предмета] - отримати дані про ваші таски\n"
                                            "   /homeWorkMainInfo - виводить все ваше домашнє завдання\n"
                                            "   /homeWorkDell [назву предмету, де ви хочете видалити дані]\n\n"
                                            
                                                                     
                                            "<b>Функції штучного інтелекту:</b>"
                                            "\n/iso [ваш запит]\n"
                                            "/api [ваш OpenAi key]\n"
                                            "/new_api [ваш новий OpenAi api-key]\n\n"
                                            "/generate_image [ваш запит]\n"
                                            "/remove_background - після цієї команди скиньте фото, для якого ви бажаєте видалити background\n\n"
                                            "/uk_ocr - розпізнає текст українською мовою із зображення\n"
                                            "/ocr - розпізнає текст англійською, німецькою, французькою мовою із зображення\n\n"
                                            
                                            "<b>Інші функції:</b>"
                                            "\n/resources [ваш запит] - отримання посилань на сайти, базуючись на вашому запиті\n"
                                            "/info - новини\n"
                                            "/weather [місто]\n\n"
                                            "Також бот може автоматично переводити аудіофайли з української та російської мови", 
                           reply_markup=HELP)
    
    student.select_all()



"""                                                         """
"""                                                         """
"""                     Schedule functions                  """
"""                                                         """
"""                                                         """



"""                                                              """
"""                                                              """
"""                Get schedule time and send data               """


@dp.message_handler(commands=['new_schedule'])
async def new_schedule(message: types.Message):
    """
    This function is the handler for the '/new_schedule' command, which allows users to add a new schedule entry.

    Args:
        message (types.Message): The message object containing the command and its parameters.

    Result:
        Adds a new schedule entry to the database and prompts the user for confirmation.
    """
    
    
    """ 
    1. Update user information:
        - Get the user ID from the message.
        - Update the username and add the user to the database.

    """
    user_id = message.from_user.id
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)

    text = message.text.strip()
    

    """ 
    2. Parse and validate the command parameters:
        - Extract the text from the message.
        - Check if the command starts with '/' to ensure it's a valid command.
        - If a specific group is required to execute the command:
            - Check if the user has specified their group using the '/my_group' command.
            - If not, send a reply to the user requesting them to provide their group. 

    """
    if text.startswith("/"):

        command = text.split()[0]

        if command_groups.get(command, False):
            user_id = message.from_user.id

            if not student.check_group_for_user(user_id):
                
                await message.reply("<b>Для виконання цієї команди необхідно вказати свою групу за допомогою команд /my_group</b>")
                return
            
    if len(message["text"]) <= 13:
        await message.reply("<b>Після /new_schedule Напишіть  день неділі, назву предмета, час у форматі година:хвилина (16:30)</b>\nЩоб все коректно обробити, дані пишіть через кому, наприклад:\n/new_schedule <b> 'Понеділок', 'вища математика', '18:00'</b>")
        return
    list_data_to_insert_in_table = [x.strip() for x in message["text"][13:].split(",")]

    if len(list_data_to_insert_in_table)  < 3:
        print("len < 4")    
        await message.reply("<b>Після /new_schedule Напишіть  день неділі, назву предмета, час у форматі година:хвилина (16:30)</b>\nЩоб все коректно обробити, дані пишіть через кому, наприклад:\n/new_schedule <b> Понеділок, вища математика, 18:00</b>")
        return

    """
    3. Parse the schedule data from the message:
        - Remove any unwanted characters (double quotes, single quotes).
        - Split the text into separate words.
        - Extract the day of the week, subject, and start time from the words.
            - Find the day of the week by matching against a list of known days.
            - Find the subject by using a fuzzy matching algorithm.
            - Find the start time by matching against a regular expression or using fuzzy matching.
    """
    day_of_week = None
    group_name  = student.check_group_for_user(user_id)
    match_time  = None
    subject     = None
    
    message_text = message["text"][13:]  # Get message text starting from 12th character
    message_text = message_text.replace('"', '').replace("'", '')  # Remove double quotes and single quotes
    words = message_text.split(" ")  # Split text into separate words
    subject_list_data  =message_text.split(",")

    for word in words:
        match_day = process.extractOne(word, config.days_of_week, score_cutoff=70)
        match_subject = subject_list_data[1]

        """ Finding the subject in user input """
        if match_subject is not None and subject is None:
            subject = match_subject
        else:
            match_subject = process.extractOne(word, config.available_subjects, score_cutoff=50)
       
        """ Finding the day of the week in user input """
        if  match_day is not None :
            day_of_week = match_day[0]
        else:
            for day in config.days_of_week:
                if day in message_text: 
                    day_of_week = day   

        """Finding time of lesson"""
        pattern = r"\b\d{1,2}:\d{2}\b"  # Regular expression for finding time in HH:MM format
        
        match_time_main = re.search(pattern, text)
        if match_time_main:
            start_time = match_time_main.group()

        else:
            match_time = process.extractOne(word, config.time, score_cutoff=80)
            if match_time is None:
                await message.reply("<b>Будь ласка, напишіть час початку без пробілів,  після назви дня неділі:\n/new_schedule назва групи, день неділіназву предмета, час у форматі година:хвилина (16:30)</b>")
                return
            start_time = match_time[0]
        

    
    """
    4. Validate the extracted data:
        - Check if the day of the week is found.
        - Check if the start time is found.
        - Check if the subject is found.
    """
    if  day_of_week is None:
        await message.reply("<b>Будь ласка, напишіть назву дня неділя без пробілів,  після назви групи:\n/new_schedule назва групи, день неділіназву предмета, час у форматі година:хвилина (16:30)</b>")
        return   
    if start_time is None:
        await message.reply("<b>Будь ласка, напишіть час початку без пробілів,  після назви дня неділі:\n/new_schedule назва групи, день неділіназву предмета, час у форматі година:хвилина (16:30)</b>")
    if  subject is None:
        await message.reply("<b>Будь ласка, напишіть назву предмета ще раз\n/new_schedule назва групи, день неділіназву предмета, час у форматі година:хвилина (16:30)</b>")
    

    """
    
    5. Add the schedule entry:
        - If the extracted data is valid:
            - Display the extracted data to the user for confirmation.
            - Check if the time slot is already booked.
            - If not, add the schedule entry to the database.
            - Send a reply to the user confirming the added schedule entry.
        - If the data is incomplete or invalid:
            - Send a reply to the user requesting them to provide the missing or correct data.

    """
    if scheduleTable.check_booked_time(group_name, day_of_week, start_time) == False:
        await message.reply(f"❌ Цей часовий проміжок вже обран:")
        return
    await message.reply(f"<b>Ім'я групи - {group_name.lower().title()}\nдень неділі - {day_of_week.lower().title()}\nНазва предмету - {subject.lower().title()}\nПочаток - {start_time}\nПідтвердіть:</b>", reply_markup=keyboard_third)
 

    
"""                                                              """
"""     Check schedule and sending notification about lessons    """
"""                                                              """


async def check_schedule_for_all_groups():
    """
    Asynchronous task that periodically checks the schedules 
        of all users and sends reminders for upcoming lessons

    Args:
            No arguments are specified for this function. 
                The function relies on external dependencies 
                    such as the `student` object and the `bot` object, which are Database Class.

    Result:
        The function ensures that users receive timely notifications about their upcoming lessons. It retrieves the user schedules, calculates the time until the next lesson, and sends reminders when the lesson is about to start. The function also clears the sent messages after a specified interval to avoid repetitive reminders.
    """

    sent_messages = {}  # Dictionary to track sent messages for each user
    clear_interval = 30 * 60  # Clear messages every 30 minutes
    last_clear_time = time.time()
    
    while True:
        now = datetime.now().time()
        users_id = student.select_users_id()
      
        user_schedules = {}  # Dictionary to store user schedules

        # Clear sent messages if the specified interval has passed
        current_time = time.time()
        if current_time - last_clear_time >= clear_interval:
            sent_messages.clear()
            last_clear_time = current_time
    
        # Retrieve schedules for all users
        for id_data in users_id:
            try:
                tgUserSchedule = scheduleTable.get_schedule_data_using_telegramID(id_data[0], bot_utils.find_weekday())
                if tgUserSchedule is False:
                    continue
                user_schedules[id_data[0]] = tgUserSchedule
                if id_data[0] not in sent_messages:
                    sent_messages[id_data[0]] = set()  # Initialize set for tracking sent messages
            except Exception as e:
                print(f"Ошибка при получении chat ID: {e}")
                continue

        # Iterate over user schedules and check for upcoming lessons
        for user_id, tgUserSchedule in user_schedules.items():
            for data in tgUserSchedule:
                subject = data[0]
                timeStart = data[1]
                lesson_start_time = datetime.strptime(timeStart, '%H:%M').time()
                time_until_lesson = timedelta(seconds=int((datetime.combine(datetime.today(), lesson_start_time) - datetime.combine(datetime.today(), now)).total_seconds()))
                print(f"time_until_lesson: {time_until_lesson}, user_id: {user_id}, subject: {subject}")

                if time_until_lesson <= timedelta(minutes=5) and time_until_lesson >= timedelta():
                    if subject not in sent_messages[user_id]:  # Check if message was already sent
                        try:
                            message = (
                                f"До  \"{subject}\" залишилось менше 5 хвилин😱😱😱\n"
                                f"Посилання: \nhttps://teams.microsoft.com/_#/calendarv2"
                            )

                            await bot.send_message(chat_id=user_id, text=message)
                            
                        except exceptions.CantInitiateConversation:
                            sent_messages[user_id].add(subject)  # Add subject to set of sent messages

        await asyncio.sleep(240)



"""                                                                                       """
"""     Return schedule of day, using database group name data, linking to telegram id    """
"""                                                                                       """

@dp.message_handler(commands=['schedule_day'])
async def schedule_day(message: types.Message, day_num: str = None):
    """
    This function handles the '/schedule_day' command to retrieve the schedule for a specific day.
    Args:
        message ['Day of week']:
            day_num (optional): The day of the week specified in the command (e.g., 'Понеділок'). Defaults to None.
    Result:
        None
    """
    if message["from"]["is_bot"] == True:
        user_id = message["chat"]["id"]
        # Here was correcting
        student.update_username(user_id, message["chat"]["first_name"])
        student.add_user(user_id, message["chat"]["first_name"])

    else:
        user_id = message.from_user.id
        student.update_username(user_id, message.from_user.first_name)
        student.add_user(user_id, message.from_user.first_name)
    
    text = message.text.strip()
    

    # Whether the text is a command

    """ Handle commands """
    if text.startswith("/"):
        # team name
        command = text.split()[0]
        # whether a group is needed to execute the command
        print(command)
        if command_groups.get(command, False):
            # Get user id
            user_id = user_id

            # Check if the user has specified their group
            if not student.check_group_for_user(user_id):
                await message.reply("<i>Для виконання цієї команди необхідно вказати свою групу за допомогою команд /my_group</i>")
                return
            
    
    if len( message["text"] ) <= 16:
        await message.reply("Після /schedule_day Напишіть день неділі, наприклад:\n/schedule_day Понеділок")
        
    else:
        group_name = student.check_group_for_user(user_id)
        current_day_schedule = scheduleTable.get_schedule_message(group_name, message['text'][16:].strip())
        day = message["text"][16:].strip()
   
        choices = ['Понеділок', 'Вівторок', 'Середа', 'Четверг', "П'ятниця", 'Субота', 'Неділя']
        match = process.extractOne(day, choices)
     
        available_groups = scheduleTable.select_all_groups()
        available_groups_text = " "
        if match[1] > 60:  # minimum similarity threshold
            current_day_schedule = scheduleTable.get_schedule_message(group_name, match[0])
            print(current_day_schedule)
            if current_day_schedule:
                schedule_message = " "
                # do something
                for item in current_day_schedule:
                    formatting_message = f"<b>{item[0]}</b> :  <b>{item[1]}</b>\n"
                    print(f"{item[0]} : {item[1]}")
                    schedule_message += formatting_message
                await message.reply(f"<b>У {match[0]} у Вас:\n{schedule_message}</b>")
            else:
                await message.reply(f"No schedule found for {match[0]}.")      
        else:
            if not len( message["text"] ) <= 13:
                await message.reply("День невірний")
        



"""                                                                                            """
"""     Just schedule of current day, using database group name data, linking to telegram id   """
"""                                                                                            """
@dp.message_handler(commands=['schedule'])
async def test_schedule(message: types.Message):
    """
    This function handles the '/schedule' command to retrieve the schedule for the current day.
    Args:
        None

    Result:
        None
    """

    current_time = time.strftime("%H:%M")
   
    user_id = message.from_user.id
    current_day_schedule = scheduleTable.get_schedule_message(student.check_group_for_user(user_id), bot_utils.find_weekday())
   
    if current_day_schedule:
        schedule_message = " "
        for item in current_day_schedule:
            formatting_message = f"<b>{item[0]}</b> :  <b>{item[1]}</b>\n"
           
            schedule_message += formatting_message
   
        await bot.send_message(message.chat.id, f"Розклад {bot_utils.find_weekday()}:\n{schedule_message}")
    else:
        await bot.send_message(message.chat.id, "<b>На сьогодні у вас немає занять, або ви не добавили їх у свій розклад:\n/new_schedule</b>")



"""                                                              """
"""                  HomeWork adding and checking                """
"""                                                              """
"""                                                              """

@dp.message_handler(commands=['homeWorkAdd'])
async def homeWork(message: types.Message):
    """
    Handles the '/homeWorkAdd' command and processes the user's input to add homework tasks.

    Args:
        message: The message object containing the user's input: [subject name] [homework]

    Returns:
        None
        To database writing user homework data 
    """

    user_id = message.from_user.id

    if len(message["text"]) <= 9:
        await message.reply(f"{message.from_user.first_name}, Після <b>/homeWorkAdd введіть назву предмета, та домашнє завдання</b>, через кому")
        return
    data = message.text[9:].split(",")  # Get the text of the task by removing '/homeWork ' from the message
    if len(data) < 2:
        await message.reply(f"{message.from_user.first_name}, Будь ласка, після <b>/homeWorkAdd введіть назву предмета, та домашнє завдання</b>, через кому")
        return
    homework = "" 
    for word in data:
        matchSubject = process.extractOne(word, config.available_subjects, score_cutoff=70)
        
        print(matchSubject)
        if matchSubject:
            subject = matchSubject[0]
            break
    homework = data[1:]
    homeWorkText = ' '.join(homework)
    if homeWorkText and subject:
        homeworkData.add_homework(user_id, subject, homeWorkText)

        homework_data = homeworkData.get_homework(user_id, subject)
        homeworkDataText = '\n'.join(f"{i+1}. {item}" for i, item in enumerate(homework_data))
        await message.reply(f"✅ <b>Домашнє завдання '{homeWorkText}' для предмету '{subject}' було успішно добавлено.\n{homeworkDataText}.</b>")
    else:
        await message.reply(f"{message.from_user.first_name}, Будь ласка, після <b>/homeWork введіть правильну назву предмета, та домашнє завдання</b>, через кому")


@dp.message_handler(commands=['homeWorkInfo'])
async def homeWorkInfo(message: types.Message):
    """
    Handles the '/homeWorkInfo's.

    Args:
        message: Subject name

    Returns:
        From database read user homework data, basing on his telegram id -> subject name
        Sending user homework data on special subject
    """
    user_id = message.from_user.id

    if len(message["text"]) <= 13:
        await message.reply(f"{message.from_user.first_name}, Після <b>/homeWorkInfo введіть назву предмета</b>")
        return
    
    user_subject_list = homeworkData.get_user_subjects(user_id)

    if len(user_subject_list) == 0:
        await message.reply(f"Наразі у вас немає домашнього завдання ні для якого предмету.\nЩоб його добавити, введіть/homeWorkAdd назва предмету, домашнє завдання.</b>")
        return 
    
    matchSubject = process.extractOne(message["text"][13:], user_subject_list, score_cutoff=70)
 
    subject_list_text = '\n'.join(f"{i+1}. {item}" for i, item in enumerate(user_subject_list))
  
    if matchSubject is  None:
       await message.reply(f"{message.from_user.first_name}, <b>назви предмету, який ви вказали, немає у вашому списку. Предмети, по яким ви записали домашнє завдання:\n{subject_list_text}.</b>")
       return
    
    subject = matchSubject[0]

    try:
        homework_data = homeworkData.get_homework(user_id, subject)
        if len(homework_data) == 0:
            await message.reply(f"Наразі у вас немає домашнього завдання для цього предмету.\nЩоб його добавити, введіть/homeWorkAdd назва предмету, домашнє завдання.</b>")
            return 
        homeworkDataText = '\n'.join(f"{i+1}. {item}" for i, item in enumerate(homework_data))

        await message.reply(f"<b>Ваше домашнє завдання для предмету '{subject}':\n{homeworkDataText}.</b>")

    except Exception as e:
        await message.reply(f"{message.from_user.first_name}, <b>прошу вибачення, виникла помилка, попробуйте ще раз указати назву предмету</b>")
        return
   
 
@dp.message_handler(commands=['homeWorkDell'])
async def homeWorkDell(message: types.Message):
    """
    Delete homework data from database, basing on telegram id -> and subject name 
    """
    user_id = message.from_user.id
    if len(message["text"]) <= 13:
        await message.reply(f"{message.from_user.first_name}, <b>Після команди /homeWorkDell введіть назву предмету, де ви хочете видалити дані.</b>")
        return
    
    user_subject_list = homeworkData.get_user_subjects(user_id)

    if len(user_subject_list) == 0:
        await message.reply(f"<b>Наразі у вас немає домашнього завдання ні для якого предмету.\nЩоб його добавити, введіть:\n/homeWorkAdd назва предмету, домашнє завдання</b>")

        return 
    
    matchSubject = process.extractOne(message["text"][13:], user_subject_list, score_cutoff=70)
    
    if matchSubject is None:
       await message.reply(f"{message.from_user.first_name}, <b>Назви предмету, який ви вказали, немає у вашому списку. Предмети, по яким ви записали домашнє завдання:\n{subject_list_text}.</b>")
       return
    
    subject = matchSubject[0]
    
    try:
        homeworkData.remove_homework_from_subject(user_id, subject)
        user_subject_list = homeworkData.get_user_subjects(user_id)
        subject_list_text = '\n'.join(f"{i+1}. {item}" for i, item in enumerate(user_subject_list))
        if len(user_subject_list) > 0:
            await message.reply(f"<b>Домашнє завдання для предмету '{subject}' було видалено.\n Предмети з наявним домашнім завданням:\n{subject_list_text}</b>")
        else:
            await message.reply(f"<b>Домашнє завдання для предмету '{subject}' було видалено.\nНаразі у вас немає домашнього завдання ні для якого предмету.</b>")

    except Exception as e:
        await message.reply(f"{message.from_user.first_name}, <b>прошу вибачення, виникла помилка, попробуйте ще раз указати назву предмету</b>")
        return


@dp.message_handler(commands=['homeWorkMainInfo'])
async def homeWorkMainInfo(message: types.Message):
    """
    Sending user homework data about all his subject, that he have 
    """
    user_id = message.from_user.id
 
    user_subject_list = homeworkData.get_user_subjects(user_id)
    
    user_home_work_list = []
    for homework in user_subject_list:
        subject_dict = {}
        subject_dict["key"] = homework
        subject_dict["value"] = homeworkData.get_homework(user_id, homework)
        user_home_work_list.append(subject_dict)
    
    if len(user_home_work_list) == 0:
        await message.reply(f"<b>Наразі у вас немає  домашього завдання ні для жодного предмету.</b>")
        return
    
    response_text = ""
    for item in user_home_work_list:
        response_text += f"\n{item['key']}\n"
        for i, value in enumerate(item['value'], start=1):
            response_text += f"{i}. {value}\n"
    
    await message.reply(f"<b>{response_text}</b>")
    





"""                                                              """
"""                     Document Creating                        """
"""                                                              """
"""                                                              """
@dp.message_handler(commands=['doc', 'docs'])
async def newDoc(message: types.Message):
    """
    Generates a document title based on the user's input and sends it back to the user.
    File creating and processing in ---bot_utils--- file, ---document_creating--- function
    Args:
        message: The message object containing the user's input.

    Returns:
        Send document .docx to user
    """

    # Checking if the command has enough arguments

    if len(message["text"]) <= 5:
        await message.reply(f"{message.from_user.first_name}, <b>Після команди /doc напишіть:\nНазву дисципліни, назву групи, ім'я студента, ім'я вчителя\nЩоб все коректно обробити, напшіть дані через кому</b>")
        return
    doc_data = message["text"][5:].split(",")
  
    if not len(doc_data) == 4:
        await message.reply(f"{message.from_user.first_name}, <b>Після команди /doc треба написати:\nНазву дисципліни, назву групи, ім'я студента, ім'я вчителя\nЩоб все коректно обробити, напшіть дані через кому</b>")
        return
    try:
        # Creating the document using the provided data

        bot_utils.document_creating(doc_data[0], doc_data[1], doc_data[2], doc_data[3])
        with open('yourVariant.docx', 'rb') as file:
        # Sending a file to a user
            await bot.send_document(message.chat.id, document=file)
            os.remove('yourVariant.docx')
    except Exception as e:
        print(e)
        await message.reply(f"{message.from_user.first_name}, <b>ви ввели невірні дані.\nПісля команди /doc напишіть:\nНазву дисципліни, назву групи, ім'я студента, ім'я вчителя\nЩоб все коректно обробити, напишіть дані через кому</b>")
   
    


@dp.message_handler(commands=['specialDoc'])
async def create_document(message: types.Message):
    """
    Generates a document based on the user's input, chatgpt answers and sends it back to the user.
    File creating and processing in ---bot_utils--- file, ---document_creating_for_speccial_topic--- function
    it use AI_responce_without_log functions to get chatgpt responce, that using in document
    Args:
        message: The message object containing the user's input.

    Returns:
        Send document .docx to user
    """
    if len(message["text"]) <= 11:
        await message.reply(f"{message.from_user.first_name}, Після /specialDoc введіть назву теми")
        return
    try:
        bot_utils.document_creating_for_speccial_topic(message["text"][11:])
        with open('yourVariant.docx', 'rb') as file:
        # Sending a file to a user
            await bot.send_document(message.chat.id, document=file)
            os.remove('yourVariant.docx')
    except Exception as e:
        print(e)
        await message.reply(f"<b>Прошу вибачення, зараз у серверах OpenAi деякі технічні неполадки.</b>")





"""                                                                     """
"""                                                                     """
"""                                                                     """
"""                                                                     """
"""         Translating and insert to DB user words                     """
"""         Main Aim: to learn new words from differenst languages      """
"""                                                                     """
"""                                                                     """
"""                                                                     """

@dp.message_handler(commands=['word', 'uword'])
async def newWord(message: types.Message):
    """
    Handles the '/word' and '/uword' commands.

    Args:
        message: The message object containing the command and text.

    Action:
        1. Translates the word and sends the translation to the user.
        2. Adds the translated word to the dictionary (DB).

    Comments:
        - The function handles two commands: '/word' and '/uword'.
        - '/word' command: Translates the word to Ukrainian and sends the translation to the user.
        - '/uword' command: Translates the specified Ukrainian text to the specified language and sends the translation to the user.
        - If the command is not followed by valid parameters, appropriate error messages are sent.
        - The translated word is added to the dictionary with the corresponding language.
    """
    user_id = message.from_user.id
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    
    # Check if the message length is less than or equal to 5
    if len(message.text) <= 5:
        await message.answer("<b>Після команди /word введіть текст</b>")
        return

    word = message.text[6:]
    is_uword_command = 'uword' in message.text[1:]

    # Handle '/uword' command
    if is_uword_command:
        # Check if the command is followed by the language and the text to translate
        if len(message.text) <= 6:
            await message.answer(f"<b>Будь ласка, після команди /uword напишіть мову, на яку треба зробити переклад, і текст українською мовою, наприклад:\n/uword Німецька, Як справи?</b>")
            return

        process_text = word.strip().split(",")
        if len(process_text) < 2:
            await message.answer(f"<b>Будь ласка, одразу після команди /uword напишіть мову, на яку треба зробити переклад, і текст українською мовою,  наприклад:\n/uword Німецька, Як справи?</b>")
            return

        sentence_to_translate = "".join(process_text[1:])
        print(sentence_to_translate)

        # Extract the language and check if it is valid
        lang = process.extractOne(process_text[0], bot_utils.language_names.values(), score_cutoff=60)
        if lang is None:
            await message.answer(f"<b>Будь ласка, після команди /uword напишіть мову українською.</b>")
            return

        detected_language = next(key for key, val in bot_utils.language_names.items() if val == lang[0])
        
        # Translate the text and send the response
        translated_word = bot_utils.translate_text(text=sentence_to_translate, source_lang="uk", target_lang=detected_language, detect_language=False)
        await message.answer(f"<b>Переклад з української на {lang[0]}:\n\n{translated_word}</b>")
        translated_word += '.'
        wordDataBase.add_word(user_id, lang[0].capitalize(), translated_word)
        return

    
    translated_word, source_lang = bot_utils.translate_text(text=word, source_lang="", target_lang="uk", detect_language=True)

    try:
        examples = bot_utils.AI_responce_without_log(message=f"Переведи слово '{word}' українською, та напиши  3 приклади для слова {word} на {source_lang} мові, без пояснень.", language_target=True)
        await message.answer(f"<b>{examples}</b>")
    except openai.error.RateLimitError:
        await message.answer(f"<b>Прошу вибачення, забагато запитів к OpenAi</b>")
        
    translated_word += '.'
    wordDataBase.add_word(user_id, source_lang.capitalize(), word)
    
   
async def words_list_callback(callback_query: types.CallbackQuery):
    """
    Handler  the '/word_list' command.

    Args:
        callback_query: The callback query object.

    Action:
        Send to user a word-list 
    """
    user_id = callback_query.from_user.id

    # Retrieve all words data for the user
    test = wordDataBase.display_all_data(user_id)

    words_dict = dict(test)
    response = ""
    # Iterate over the languages and phrases in the words dictionary
    for language, phrases in words_dict.items():
        response += f"{language}:\n"
        # Clean up the phrases string and split into a list
        phrases = phrases.replace("[", "").replace("]", "").replace("'", "")
        phrases_list = phrases.strip().split(".")
    

        # Iterate over the phrases list and add them to the response
        for i, phrase in enumerate(phrases_list, 1):
            response += f"   {i}. {phrase}\n"
    response = response.strip()

    
    await bot.send_message(callback_query.message.chat.id ,f"<b>Всі слова:\n{response}</b>")



@dp.message_handler(commands=['word_list', 'list_word'])
async def words_list(message: types.Message):
    """
    Handler for the 'word_list' command. list_word make the same

    Args:
        None.

    Action:
        Get user dictionary from DB and send it to him.
    """


    user_id = message.from_user.id
    
    print(message)

    # Retrieve all words data for the user
    test = wordDataBase.display_all_data(user_id)
    if len(test) == 0:
        await message.reply(f"<b>У вас немає наявних слів</b>")
        return
    words_dict = dict(test)
    response = ""
    for language, phrases in words_dict.items():
        response += f"{language}:\n"
        phrases_list = eval(phrases)  # Преобразование строки в список с помощью eval()
        for i, phrase in enumerate(phrases_list, 1):
            response += f"   {i}. {phrase}\n"
    
    await message.reply(f"<b>{response}</b>")
  

@dp.message_handler(commands=['certain_words'])
async def certainWordList(message: types.Message):
    """
    Handler  the 'certain_words' command.

    Args:
        Language

    Action:
        Give user a list of his words in certain language.
    """
    user_id = message.from_user.id
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)

    # Check if the command is followed by a language
    if len(message["text"]) <= 14:
        await message.reply(f"<b>Будь ласка, після команди /certainWord введіть мову, щоб отримати список ваших слів.</b>")
        return
    
    # Extract the language and retrieve specific language words for the user
    language = process.extractOne(message["text"][15:], bot_utils.language_names.values(), score_cutoff=60)
    test = wordDataBase.get_specific_language_words(user_id, language[0].capitalize())
    if len(test) == 0:
        await message.reply(f"<b>Для вашої мови не було знайдено слів\nСписок мов та ваших слів:\n</b>")
        await words_list(message)
        return
    response = f"{language[0].capitalize()}:\n"

    # Iterate over the specific language words and add them to the response
    for i, word in enumerate(test, 1):
        response += f"  {i}. {word}\n"

    await message.reply(f"<b>{response}</b>")



@dp.message_handler(commands=['word_done'])
async def word_done(message: types.Message):
    """
    This function handles the '/word_done' command. It marks a word as completed for a specific language.

    Args:
    - message: The message object containing the command and arguments.

    Result:
    - The function marks the specified word as completed for the given language and sends a response message.

    """
    user_id = message.from_user.id

    if len(message["text"]) <= 10:
        await message.reply(f"<b>Будь ласка, після команди /word_done напишіть мову, та номер слова, який ви вже вивчили. Наприклад:\n/word_done Німецька, 1</b>")
        return
    
    message_main = message["text"][11:].split(",")
    if not len(message_main) == 2:
        await message.reply(f"<b>Будь ласка, після команди /word_done напишіть мову, та номер слова, який ви вже вивчили. Наприклад:\n/word_done Англійська, 1</b>")
        return
    
    user_language = message_main[0].strip()
    index = message_main[1].strip()
    print(index)

    if index.isnumeric() == False:
        await message.reply(f"<b>Будь ласка, напішить номер слова, наприклад: 1</b>")
        return
    
    language = process.extractOne(user_language, bot_utils.language_names.values(), score_cutoff=60)
  
    if language is None:
        await message.reply(f"<b>Не було знайдено мови</b>")
        return

    test = wordDataBase.get_specific_language_words(user_id, language[0].capitalize())
    
    if len(test) == 0:
        await message.reply(f"<b>Для мови '{language[0].capitalize()}' не було знайдено ваших слів.</b>")
        return
    
    print(language[0].capitalize())
    check_list = wordDataBase.add_checkmark_to_word(user_id, language[0].capitalize(), int(index) - 1)
    
    words_done = 0 
    for sentence in test:
        if "✅" in sentence:
            words_done += 1
    if len(test) == words_done:
        response = f"{language[0].capitalize()}:\n"
        # Iterate over the specific language words and add them to the response
        for i, word in enumerate(test, 1):
            response += f"  {i}. {word}\n"  
        await message.reply(f"<b>Check Mark був добавлен ко всім словам до мови {language[0].capitalize()}:\n{response}\n</b>\nВидалити слова?", reply_markup=keyboard_five)
        
        return
    
    if check_list == False:
        await message.reply(f"<b>Будь ласка, введіть дійсний номер слова.</b>")
        
        response = f"{language[0].capitalize()}:\n"
        # Iterate over the specific language words and add them to the response
        for i, word in enumerate(test, 1):
            response += f"  {i}. {word}\n"
            
        await message.reply(f"<b>{response}</b>")
        
        return
    
    if check_list == "Its was checked":
        await message.reply(f"<b>Check list вже поставлен на цьому номеру слова</b>")
        return
    
    test = wordDataBase.get_specific_language_words(user_id, language[0].capitalize())
    
    response = f"{language[0].capitalize()}:\n"
    # Iterate over the specific language words and add them to the response
    for i, word in enumerate(test, 1):
        response += f"  {i}. {word}\n"
            
    await message.reply(f"<b>Check Mark був добавлен:\n{response}</b>")
    
    


@dp.message_handler(commands=['remove_words'])
async def remove_words(message: types.Message):
    """
    This function handles the '/remove_words' command. It removes all words for a specific language.

    Args:
        - message: The message object containing the command and arguments.

    Result:
        - The function removes all words for the specified language and sends a response message.
    """

    user_id = message.from_user.id

    if len(message['text']) <= 13:
        await message.reply(f"<b>Будь ласка, після команди /remove_words напишіть мову.</b>")
        return

    process_text = message['text'][14:].strip()
    language = process.extractOne(process_text, bot_utils.language_names.values(), score_cutoff=60)
    if language is None:
        await message.answer(f"<b>Будь ласка, після команди /remove_words напишіть мову українською.</b>")
        return
    
    test = wordDataBase.get_specific_language_words(user_id, language[0].capitalize())
    
    if len(test) == 0:
        await message.reply(f"<b>Для мови '{language[0].capitalize()}' не було знайдено ваших слів.</b>")
        return
    
   
    wordDataBase.remove_words_by_language(user_id, language[0].strip().capitalize())
    await message.reply(f"<b>Слова для мови '{language[0].capitalize()}' Були видалені.</b>")
    await words_list(message)





"""                                                              """
"""                         Todo list                            """
"""                                                              """
"""                                                              """

@dp.message_handler(commands=['new_task'])
async def new_task(message: types.Message):
    
    """
    This function handles the '/new_task' command. It writes a new user task to the database.

    Args:
        - message: The message object containing the user's input.

    Result:
        - The function adds the user's task to the database and sends a response message.
    """


    user_id = message.from_user.id
    if len(message["text"]) <= 9:
        await message.reply(f"{message.from_user.first_name}, Після /new_task введіть свій таск")
        return
    task = message.text[9:]  # Get the text of the task by removing '/add ' from the message
    if not student.add_task(user_id, task):
        tasks = student.get_tasks(user_id)
        tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)])  
        await message.reply(f"<b>😞 Ліміт тасків - 10\n\n{tasks_text}</b>")
        return 
    tasks = student.get_tasks(user_id)

    tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)]) # Adding serial numbers to each element

    await message.reply(f"<b>🥳 Таск '{task}' було успішно добавлено\n{tasks_text}</b>")


@dp.message_handler(commands=['task_list'])
async def task_list(message: types.Message):
    """
    This function handles the '/task_list' command. It returns the user's task data.

    Args:
        - message: The message object (doesn't need to contain user input).

    Result:
        - The function retrieves the user's tasks from the database and sends a response message.
    """
    user_id = message.from_user.id
    tasks = student.get_tasks(user_id)
    
    if len(tasks) == 0:
        await message.reply(f"<b>{message.from_user.first_name}, наразі у вас немає тасків.\nЩоб їх добавити, введіть команду:\n/new_task та назва вашого таску</b>")
        return
    tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)])
    await message.reply(f"<b>Ваші таски:\n{tasks_text}</b>")
   

@dp.message_handler(commands=['task_done'])
async def task_done(message: types.Message):
    """
    This function handles the '/task_done' command. It marks the user's task as done.

    Args:
        - message: The message object containing the user's input -> [task number]

    Result:
        - The function marks the specified task as completed in the database and sends a response message.
    """
    user_id = message.from_user.id
    tasks = student.get_tasks(user_id)
    
    if len(tasks) == 0:
        await message.reply(f"<b>{message.from_user.first_name}, у вас немає тасків.\nЩоб їх добавити, введіть команду:\n/new_task та назва вашого таску</b>")
        return
 
    if len(message["text"]) <= 10:
        await message.reply(f"<b>{message.from_user.first_name}, після /task_done введіть номер таску, який  ви бажаєте встановити як вирішений</b>")
        return
    if not message["text"][11:].isdigit():
        await message.reply(f"<b>{message.from_user.first_name}, будь ласка, введіть номер таску</b>")
        return
    
    if int(message["text"][11:]) > len(tasks):
        await message.reply(f"<b>{message.from_user.first_name}, таску під номером, який ви ввели, не дійсний</b>")
        return
    
    result = student.mark_task_as_completed(user_id, int(message["text"][11:]) - 1)
    
    if result == "Задача вже відмічена, як виконана":
        await message.reply(f"<b>{message.from_user.first_name}, задача вже відмічена, як виконана</b>")
        return
    
    tasks = student.get_tasks(user_id)
    
    tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)])

    if len(tasks) >= 1:
        await message.reply(f"<b>Таск ліст було успішно змінено:\n{tasks_text}</b>")
    if result == "Всі таски виконані":
        
        await message.reply(f"<b>Всі таски виконані, чи бажаєте ви видалити їх?</b>", reply_markup=keyboard_four)
 

@dp.message_handler(commands=['taskRemove'])
async def taskRemove(message: types.Message):
    """
    This function handles the '/taskRemove' command. It removes the user's task.

    Args:
        - message: The message object containing the user's input -> [task number]

    Result:
        - The function removes the specified task from the database and sends a response message.
    """
    user_id = message.from_user.id
    tasks = student.get_tasks(user_id)
    
    
    if len(tasks) == 0:
        await message.reply(f"<b>{message.from_user.first_name}, у вас немає тасків.\nЩоб їх добавити, введіть команду:\n/new_task та назва вашого таску</b>")
        return
    
    if len(message["text"]) <= 11:
        await message.reply(f"<b>{message.from_user.first_name}, після /taskRemove введіть номер таску, який  ви бажаєте видалити</b>")
        return
    if not message["text"][11:].strip().isdigit():
        await message.reply(f"<b>{message.from_user.first_name}, будь ласка, введіть номер таску</b>")
        return
    
    if int(message["text"][11:]) > len(tasks):
        await message.reply(f"<b>{message.from_user.first_name}, таску під номером, який ви ввели, не дійсний</b>")
        return
    
    result = student.delete_task_from_list(user_id, int(message["text"][11:]) - 1)
    
    
    tasks = student.get_tasks(user_id)
    
    tasks_text = '\n'.join([f"{i+1}. {task}" for i, task in enumerate(tasks)])

    if len(tasks) >= 1:
        await message.reply(f"<b>Таск ліст було успішно змінено:\n{tasks_text}</b>")
    elif len(tasks) == 0:
        await message.reply(f"<b>Таск ліст було успішно змінено.\nВ ньому не залишилось даних.</b>")


@dp.message_handler(commands=['dell_task'])
async def dell_task(message: types.Message):
    """
    This function handles the '/dell_task' command. It asks the user for confirmation to delete task data.

    Args:
        - message: The message object (doesn't need to contain user input).

    Result:
        - The function asks the user for confirmation to delete task data and sends a response message with a confirmation keyboard.
    """
    user_id = message.from_user.id
    await message.reply(f"<b>{message.from_user.first_name}, Ви точно бажаєте видалити дані тасків?</b>", reply_markup=keyboard_four)



"""                                                              """
"""                Get group name of telegram user               """

@dp.message_handler(commands=['my_group'])
async def my_group(message: types.Message, state: FSMContext):
    """
    This function handles the '/my_group' command. It allows the user to specify their group.

    Args:
        message: The message object containing the user's input.
        state: The FSM context to track the conversation state.

    Returns:
        None
    """
    user_id = message.from_user.id
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)

    if student.check_group_for_user(message.from_user.id):
        await bot.send_message(message.chat.id, f"<b>Ви вже вказали свою групу</b>")
        return
    if len(message["text"]) <= 9:
        await bot.send_message(message.chat.id, f"<b>Після /my_group напишіть назву своєї групи</b>")
        return
   

    
    group_message_main = message["text"].replace(" ", "").replace("\t", "").replace("\n", "")
    group_message = group_message_main[9:12]
    group_all_message = group_message_main[9:]
 
    if group_message.isdigit():
        
        match = process.extractOne(group_all_message, config.available_groups, score_cutoff=85)
       
        if match is not None:
           
            await bot.send_message(message.chat.id, f"Збіг був знайден: <b>{match[0]}.</b>\nЧи вірно воно?", reply_markup=keyboard)
            
        else: 
            
            result_groups = "\n".join(config.available_groups)
            await bot.send_message(message.chat.id, f"<b>Для вашого результату <i>{group_all_message}</i> не було знайдено збігів\nдоступні групи для ідентифікації:</b><b>{result_groups}</b>")
    else:
        await bot.send_message(message.chat.id, f"<b>Назва групи повинна починатися з 3 цифр, наприклад:\n422\n422ч</b>")







"""                                                 """
"""                                                 """
"""                                                 """
"""               AI functions                      """
"""                                                 """
"""                                                 """
"""                                                 """
"""                                                 """




"""                                                 """
"""    Openai answers based on chatgpt neural net   """
"""                                                 """

@dp.message_handler(commands=['iso'])
async def handle_info_command_iso(message: types.Message):
    """
    This function handles the '/iso' command and generates a response using the OpenAI ChatGPT model.

    Args:
        message: The message object that triggered the command.

    Result:
        Sends a response generated by the ChatGPT model to the user.
    """

    user_id = message.from_user.id
    print(f"user id - {user_id} - name {message.from_user.first_name}")
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    student.select_username_and_group_name(user_id)
    
    if student.ai_check(user_id) == False and student.check_api_key(user_id) == False:
        await message.reply("<b>Прошу вибаченя, ви вичерпали кількість запитів до серверу OpenAI.\nЩоб продовжити використовувати Chatgpt, виконайти ці інструкції:\n\n1. Зайдіть на цей сайт: https://platform.openai.com/account/api-keys\n2. Натисніть на кнопку, яка знаходиться посередині '+ Create new secret key', щоб отримати api key.\nДалі введіть команду:\n/api та свій ключ.</b>")
        return
    print("---")
    print(student.ai_check(user_id) )
    print(student.check_api_key(user_id) )
    if student.check_api_key(user_id) == False:
        print("one")
        api_key = config.OpenAIKey

    else:
        print("two")
        api_key = student.get_decrypted_api_key(user_id)
    
    aichat = OpenAiChatHistory()
    chat_history = aichat.get_chat_history(user_id)
    
    try:
        if message.chat.type == types.ChatType.PRIVATE:
            gpt_response, updated_chat_history = await bot_utils.AI_response(message["text"], chat_history,message.from_user.first_name, api_key)
        else:
            gpt_response, updated_chat_history = await bot_utils.AI_response(message["text"][4:], chat_history,message.from_user.first_name, api_key)

        aichat.add_message(user_id, updated_chat_history)
        await message.reply(html.escape(gpt_response))
        student.use_ai(user_id)
    except openai.error.RateLimitError as e:
        await message.reply("<b>Перевищення ліміту запитів, будь ласка, почекайте</b>")
        return
    except openai.error.AuthenticationError:
        await message.reply("<b>Ви ввели неправильний api-key, будь ласка, перевірте на коректність.\nЩоб його змінити, введіть команду:\n/new_api та свій новий api-key</b>")
        return
    except exceptions.CantParseEntities:
        await message.reply("<b>Прошу вибаченя, помилка в запиті до серверу</b>")
        return
    


@dp.message_handler(commands=['api'])
async def handle_info_command_api(message: types.Message):
    """
    This function handles the '/api' command and allows the user to input their OpenAI API key.

    Args:
        message: The message object that triggered the command.

    Result:
        Saves the user's API key and provides a success message.
    """
    user_id = message.from_user.id
    print(f"user id - {user_id} - name {message.from_user.first_name}")
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    student.select_username_and_group_name(user_id) 

    if student.check_api_key(user_id) == True:
        await message.reply("<b>Ви вже ввели api-key, щоб його змінити, введіть команду:\n/new_api ...</b>")
        return
    if len(message["text"]) <= 4:
        await message.reply("<b>Будь ласка, після команди /api введіть свій api ключ OpenAi.\nЩоб його отримати:\n\n1. Зайдіть на цей сайт: https://platform.openai.com/account/api-keys\n2. Натисніть на кнопку, яка знаходиться посередині '+ Create new secret key', щоб отримати api key.</b>")
        return
    
    api_key = message["text"][4:]
    api_key = message["text"][4:].replace('"', '').replace("'", '')
   
    
    try:
        student.insert_api_key(user_id, api_key)
        await message.reply("<b>✅ Операція успішна, тепер можете користуватися функцією /iso</b>")
    except Exception as e:
        print(e)
        await message.reply("<b>Прошу вибачення, виникла помилка</b>")

@dp.message_handler(commands=['new_api'])
async def handle_info_command_new_api(message: types.Message):
    """
    This function handles the '/new_api' command and allows the user to update their OpenAI API key.

    Args:
        message: The message object that triggered the command.

    Result:
        Updates the user's API key and provides a success message.
    """
    user_id = message.from_user.id
    print(f"user id - {user_id} - name {message.from_user.first_name}")
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    student.select_username_and_group_name(user_id) 

    if len(message["text"]) <= 8:
        await message.reply("<b>Будь ласка, після команди /new_api введіть новий api-key.</b>")
        return
    new_api_key = message["text"][9:]
    new_api_key = message["text"][9:].replace('"', '').replace("'", '')
   
    try:
        student.insert_api_key(user_id, new_api_key)
        await message.reply("<b>✅ Операція успішна, ваш api-key було обновлено</b>")
    except Exception as e:
        print(e)
        await message.reply("<b>Прошу вибачення, виникла помилка</b>")




"""                                                                 """
"""  Generate Image, using Openai neural network DALL-E API         """
"""                                                                 """
@dp.message_handler(commands=['generate_image'])
async def generate_command_handler(message: Message):
    try:
        
        if len(message["text"]) == 15:
            await message.reply("Після /generate_image введіть опис")
            return 
        
        description = message["text"][15:].strip()
        loop = asyncio.get_event_loop()

        # Get a link to the image in a separate thread 
        image_url = await loop.run_in_executor(None, bot_utils.generate_image, description)

        # Download image
        image_data = requests.get(image_url).content

        # Send image to user
        await bot.send_photo(chat_id=message.chat.id, photo=image_data)
    except Exception as e:

        # If an error occurs, send it to the user
        error_message = str(e)
        if "Your request was rejected" in error_message:
            error_message = "Ваш запит було відхилено протоколами безпеки. Спробуйте змінити опис зображення."
            await message.reply(error_message)



    
"""                                                                                 """
"""                     Removing background from Image                              """
"""                                                                                 """

class PhotoProcessingState:
    def __init__(self):
        self.processing_photo = False

photo_processing_state = PhotoProcessingState()

@dp.message_handler(Command('remove_background'))
async def remove_background_command(message: types.Message, state: FSMContext):
    # Giving user info
    await message.reply("Будь ласка, відправте фото для обробки.")
    
    # Set the processing state for the current user
    await state.set_state('processing_photo')
    photo_processing_state.processing_photo = True

@dp.message_handler(content_types=types.ContentTypes.PHOTO, state='processing_photo')
async def process_photo(message: types.Message, state: FSMContext):
    # Taking photo file
    photo = message.photo[-1]
    # Getting file info
    file_info = await bot.get_file(photo.file_id)
    file_path = file_info.file_path

    # Downloading photo file 
    downloaded_photo = await bot.download_file(file_path)

    # Create a temporary file for processing
    photo_path = "photo.png"
    with open(photo_path, "wb") as file:
        file.write(downloaded_photo.getvalue())

    # Processing the photo
    processed_photo_path = "processed_photo.png"
    bot_utils.backGroundRemove(photo_path, processed_photo_path)

    # Send the processed photo to the user
    with open(processed_photo_path, "rb") as file:
        await bot.send_photo(message.chat.id, InputFile(file))

    # Delete temporary files
    os.remove(photo_path)
    os.remove(processed_photo_path)

    # Reset the processing state for the current user
    await state.finish()
    photo_processing_state.processing_photo = False




"""                                                 """
"""                 Image to text                   """
"""                                                 """

class OCRState(StatesGroup):
    waiting_for_photo = State()

class UkOCRState(StatesGroup):
    waiting_for_photo = State()


@dp.message_handler(commands=['uk_ocr'])
async def uk_ocr_command_handler(message: types.Message):
    """
    This function handles the '/uk_ocr' command and requests the user to send a photo for text recognition.

    Args:
        message: The message object that triggered the command.
    """
    # Sending a message with a request to send a photo
    await message.reply("Будь ласка, відправте фото для розпізнавання тексту.")

    # Set photo standby state
    await UkOCRState.waiting_for_photo.set()


@dp.message_handler(content_types=types.ContentTypes.PHOTO, state=UkOCRState.waiting_for_photo)
async def photo_received_handler(message: types.Message, state: FSMContext):
    """
    This function handles the photo received in response to the '/uk_ocr' command and performs text recognition in ukrainian languages.

    Args:
        message: The message object that contains the received photo. 
        state: The FSMContext object for managing the state of the conversation.

    Result:
        Sends the recognized text from the photo to the user.
    """
    # Get photo id
    photo_id = message.photo[-1].file_id

    # Загрузка фотографии
    photo = await bot.get_file(photo_id)
    photo_path = photo.file_path

    # Save the photo to the "photos" directory with a unique name
    save_path = os.path.join('photos', f'photo_{photo_id}.jpg')
    await photo.download(save_path)

    # Text recognising
    try:
        text = bot_utils.uk_image_to_text(save_path)
    except:
        await message.reply(f"<b>Прошу вибачення, виникла помилка.</b>")
        return
    # Send the recognized text to the user
    await message.reply(text)

    # Deleting a saved photo
    os.remove(f"photos_{photo_id}.jpg")

    # Сброс состояния
    await state.finish()


@dp.message_handler(commands=['ocr'])
async def ocr_command_handler(message: types.Message):
    """
    This function handles the '/ocr' command and requests the user to send a photo for text recognition in english, deutsch, french languages.

    Args:
        message: The message object that triggered the command.
    """
    # Sending a message with a request to send a photo
    await message.reply(f"<b>Будь ласка, відправте фото для розпізнавання тексту.</b>")

    # Set photo standby state
    await OCRState.waiting_for_photo.set()


@dp.message_handler(content_types=types.ContentTypes.PHOTO, state=OCRState.waiting_for_photo)
async def photo_received_handler(message: types.Message, state: FSMContext):
    """
    This function handles the photo received in response to the '/ocr' command and performs text recognition.

    Args:
        message: The message object that contains the received photo.
        state: The FSMContext object for managing the state of the conversation.

    Result:
        Sends the recognized text from the photo to the user.
    """
    # Get photo id
    photo_id = message.photo[-1].file_id

  
    photo = await bot.get_file(photo_id)
    photo_path = photo.file_path

    
    save_path = os.path.join('photos', f'photo_{photo_id}.jpg')
    await photo.download(save_path)

    
    try:
        text = bot_utils.image_to_text(save_path)
        print(text)
    except Exception as e:
        await message.reply(f"<b>Прошу вибачення, виникла помилка.</b>")
        return

    escaped_text = html.escape(text)
    await message.reply(escaped_text)

   
    os.remove(f"photos_{photo_id}.jpg")

    await state.finish()




"""                                           """
"""                Speech to text             """
"""                                           """

# Convert the file from ogg to wav
def convert_audio(file_path, file_name):
    """
    This function converts the audio file from ogg format to wav format.
    Args:
        file_path (str): The path of the input audio file.
        file_name (str): The name of the output audio file.
    Result:
        None
    """

    subprocess.call([config.ffmpeg_path, '-i', file_path, '-ar', '48000', file_name])


@dp.message_handler(content_types=[
    types.ContentType.VOICE,
    types.ContentType.AUDIO
    ]
)
async def voice_message_handler(message: types.Message):
    """
    This function is the handler for processing voice and audio messages.
    Args:
        message (types.Message): The message object containing the voice or audio data.
    Result:
        Send user transcription of the voice file.
    """
    if message.chat.id == -1001669920130:
        return
    user_id = message.from_user.id
 
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    
    if message.content_type == types.ContentType.VOICE:
        file_id = message.voice.file_id
    elif message.content_type == types.ContentType.AUDIO:
        file_id = message.audio.file_id
    elif message.content_type == types.ContentType.DOCUMENT:
        file_id = message.document.file_id
    else:
        await message.reply("Формат документа не поддерживается")
        return

    file = await bot.get_file(file_id)
    file_path = file.file_path
    file_on_disk = Path("", f"{file_id}.tmp")
    await bot.download_file(file_path, destination=file_on_disk)
    
   
    text = stt_rec.audio_to_text(file_on_disk)
    if not text:
        text = "Формат документа не поддерживается"
    await message.reply(text)

    os.remove(file_on_disk) 





"""                                               """
"""                                               """
"""                                               """
"""               Other functions                 """
"""                                               """
"""                                               """
"""                                               """

@dp.message_handler(commands=['chat_id'])
async def chat_id_handler(message: types.Message):
    chat_id = message.chat.id
    await message.reply(f'Chat ID: <code>{chat_id}</code>', parse_mode=ParseMode.HTML)


"""                                               """
"""                Get Weather                    """
"""                                               """

@dp.message_handler(commands=['weather'])
async def weather_info(message: types.Message, user_id: int = None):
    """
    This function handles the '/weather' command to retrieve weather information for a specific city.
    Args:
        weather [place]: The name of the city for which weather information is requested.

    Result:
        None
    """
    if message is not None and message.from_user is not None:
        user_id = message.from_user.id
        student.update_username(user_id, message.from_user.first_name)
        student.add_user(user_id, message.from_user.first_name)
    else:
        user_id = None
  
 
    try:
        if len(message.text) <=8:
            await message.reply("Після /weather введіть назву міста\nНаприклад: \n/weather Київ ")
        else:   
            weather_info, temperature = bot_utils.get_weather(message.text[8:])
            weather_info = escape(weather_info)

            await message.reply(weather_info,  parse_mode=ParseMode.MARKDOWN_V2, )
            if temperature > 12:
                photo_path = open('photos/sun.png', 'rb')
            else:
                photo_path = open('photos/cold.png', 'rb')
            await bot.send_photo(chat_id=message.chat.id, photo=photo_path)
    except Exception as e:
      print(f"Помилка: {e}")


"""                                                 """
"""         Latest info using parsing               """
"""                                                 """
@dp.message_handler(commands=['info'])
async def handle_info_command_info(message: types.Message):
    """
    This function handles the '/info' command and provides information based on the user's query.

    Args:
        message: The message object that triggered the command.

    Result:
        Sends relevant information or news based on the user's query, or general news if no specific query is provided.
    """
    user_id = message.from_user.id
 
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    if len(message["text"]) <= 5:
        await message.reply(f"<b>Будь ласка, після команди /info введіть ваш запит, наприклад:\n/info ЗСУ</b>")
        return
    try:
        news = bot_utils.newsInfo(message["text"][6:])
        if news is None:
            news_else = bot_utils.data_parser("https://www.unian.ua/") 
            news_else_str = "".join(news_else)
            await message.reply(f"<b>На ваш запит не було знайдено інформації.\n\nОсь головні події за останній день:\n{news_else_str}</b>")
            return
        news_main = "\n\n".join(news)
        await message.reply(f"<b>{news_main}</b>")
        return
    except exceptions.MessageTextIsEmpty:
        await message.reply(f"<b>Даних на сьогодні немає.</b>")


"""                                                 """
"""             Resources parsing                    """
"""                                                 """
@dp.message_handler(commands=['resources'])
async def handle_info_command_api(message: types.Message):
    """
    This function handles the '/resources' command and provides learning resources based on the user's query.

    Args:
        message: The message object that triggered the command.

    Result:
        Sends a list of learning resources and a PDF file related to the user's query, if available.
    """
    user_id = message.from_user.id
    print(f"user id - {user_id} - name {message.from_user.first_name}")
    student.update_username(user_id, message.from_user.first_name)
    student.add_user(user_id, message.from_user.first_name)
    student.select_username_and_group_name(user_id) 
    if len(message["text"]) <= 10:
        await message.reply("<b>Після команди /resources введіть запит.</b>")
        return
    
    links = bot_utils.learning_resources_links(message["text"][11:])
    links_str = "\n\n".join(links)
    if len(links) > 0:
        await message.reply(f"<b>Ваші ссилки на ресурси:\n{links_str}</b>")
        with tempfile.TemporaryDirectory() as temp_dir:
           
            bot_utils.search_pdf(message["text"][11:])
            
            with open("pdf_file.pdf", "rb") as file:
                await message.answer_document(file)
            
     
    else:
        await message.reply("<b>По вашому запиту немає інформації</b>")

    
@dp.message_handler(commands=['ping_all'])
async def ping_all(message: types.Message):

    if message.chat.id != -1001669920130:
        await bot.send_message(message.chat.id, f"<b>Доступ заборонено</b>")
        return
    
    
    for member in config.user_mentions:  
        await bot.send_message(message.chat.id, f'Ping! {member}', reply_to_message_id=message.message_id)
    
    await bot.send_message(message.chat.id, f"<b>https://teams.microsoft.com/_#/calendarv2</b>")




"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""              Callback handler commands -> Buttons               """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """



"""                             """

"""      Commands buttons       """

"""                             """
BTN_WEATHER = InlineKeyboardButton('Weather', callback_data='weather')
BTN_ISO = InlineKeyboardButton('штучний інтеллект', callback_data='iso')
BTN_INFO = InlineKeyboardButton('поточна інформація', callback_data='info')
BTN_SCH = InlineKeyboardButton('розклад', callback_data='schedule_day')
BTN_GROUP = InlineKeyboardButton('моя група', callback_data='my_group')
BTN_NEW_SCH = InlineKeyboardButton('новий розклад', callback_data='new_schedule')
BTN_Task_Add = InlineKeyboardButton('новий таск', callback_data='new_task_help')
BTN_Task_Info = InlineKeyboardButton('task info', callback_data='task_info_help')
BTN_Doc = InlineKeyboardButton('doc create', callback_data='doc_creating')
HELP = InlineKeyboardMarkup().add(BTN_ISO, BTN_SCH, BTN_NEW_SCH,BTN_GROUP,BTN_Task_Add, BTN_Task_Info, BTN_Doc,  BTN_WEATHER, BTN_INFO)


"""User input buttons"""
keyboard = InlineKeyboardMarkup()
yes_button = InlineKeyboardButton(text="Так", callback_data="group_confirm")
no_button = InlineKeyboardButton(text="Ні", callback_data="group_cancel")
keyboard.add(yes_button, no_button)

keyboard_second = InlineKeyboardMarkup()
yes_button_second = InlineKeyboardButton(text="Обновити", callback_data="update_confirm")
no_button_second = InlineKeyboardButton(text="Відміна", callback_data="update_cancel")
keyboard_second.add(yes_button_second, no_button_second)

keyboard_third = InlineKeyboardMarkup()
yes_button_third = InlineKeyboardButton(text="Підтверджую", callback_data="schedule_confirm")
no_button_third = InlineKeyboardButton(text="Відміна", callback_data="schedule_cancel")
keyboard_third.add(yes_button_third, no_button_third)


keyboard_four = InlineKeyboardMarkup()
yes_button_four = InlineKeyboardButton(text="Підтверджую", callback_data="taskDellConfirm")
no_button_four = InlineKeyboardButton(text="Відміна", callback_data="taskDellDecline")
keyboard_four.add(yes_button_four, no_button_four)


keyboard_five = InlineKeyboardMarkup()
yes_button_five = InlineKeyboardButton(text="Підтверджую", callback_data="wordsDeleteAccept")
no_button_five = InlineKeyboardButton(text="Відміна", callback_data="wordsDeleteDecline")
keyboard_five.add(yes_button_five, no_button_five)






"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                 Callback handler commands                       """
"""                                                                 """
"""                                                                 """
"""                                                                 """
"""                                                                 """

@dp.callback_query_handler(lambda c: c.data == 'weather')
async def process_callback_weather(callback_query: types.CallbackQuery):
    """ This function handles info about  /weather command. It sends a message explaining how to use the command."""

    await bot.answer_callback_query(callback_query.id)

    user_id = callback_query.from_user.id
    message_text = f'/weather Київ'  # The default value is "/weather Київ"
    message = types.Message(text=message_text, chat=callback_query.message.chat, from_user=callback_query.from_user)
    
    await weather_info(message, user_id)
 

"""                                                                                  """
"""                Button functions, to show how to use iso command (Chatgpt  AI)     """

@dp.callback_query_handler(lambda c: c.data == 'iso')
async def process_callback_ai(callback_query: types.CallbackQuery):
    """ This function handles info about  /iso command. It sends a message explaining how to use the command."""

    await bot.answer_callback_query(callback_query.id)
    user_id = callback_query.from_user.id
    await bot.send_message(callback_query.message.chat.id, f"<b>Ви можете написати /iso 'запит'\nзадля відповіді штучного інтеллекту на ваш запит</b>")
   
"""                                                                      """
"""                Button functions, to show how to use info command     """
@dp.callback_query_handler(lambda c: c.data == 'info')
async def process_callback_info(callback_query: types.CallbackQuery):
    """ This function handles info about  /info command. It sends a message explaining how to use the command."""

    await bot.answer_callback_query(callback_query.id)
    await handle_info_command_info(callback_query.message)  # Передаем callback_query.message напрямую



"""                                                                              """
"""                Button functions, to show how to use schedule_day command     """

@dp.callback_query_handler(lambda c: c.data == 'schedule_day')
async def process_callback_schedule_day(callback_query: types.CallbackQuery):
    """ This function handles info about  /schedule_day command. It sends a message explaining how to use the command."""

    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>Ви можете написати:\n<i>/schedule_day назва групи, день неділі</i>\nзадля отримання розкладу</b>")


"""                                                                              """
"""                Button functions, to show how to use new_schedule command     """

@dp.callback_query_handler(lambda c: c.data == 'new_schedule')
async def process_callback_new_schedule(callback_query: types.CallbackQuery):
    """ This function handles info about  /new_schedule command. It sends a message explaining how to use the command."""
    
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>Напишіть назву групи, день неділі, назву предмета, час у форматі година:хвилина (16:30)</b>\nЩоб все коректно обробити, дані пишіть через кому, наприклад:\n/new_schedule <b>'422', Понеділок, вища математика, 18:00</b>")




"""                                                                              """
"""                Button functions, to show how to use my_group command         """


@dp.callback_query_handler(lambda c: c.data == 'my_group')
async def process_callback_new_group(callback_query: types.CallbackQuery):
    """ This function provides information about  /my_group command. It sends a message explaining how to use the command. """
    
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>Після /my_group напишіть назву своєї групи</b>")
    

"""                                                                                      """
"""                Button functions, to confirm initializing group name, or decline      """

@dp.callback_query_handler(lambda c: c.data == 'group_confirm')
async def process_callback_group_confirm(callback_query: types.CallbackQuery):
    """ This function handles the callback when the group name setting is confirm. """
    
    await bot.answer_callback_query(callback_query.id)
    text = callback_query.message["text"]
    number_group = text.split(": ")[1].split(".")[0]
   
    if number_group:
        group_name = number_group
        
        if group_name in config.available_groups:
            user_id = callback_query.from_user.id
            student.add_user_with_group(user_id, group_name)
            await bot.send_message(callback_query.message.chat.id, f"<b>\U00002705 Вітаю, {student.select_username_and_group_name(user_id)}, ваша назва групи була записана у базу даних, тепер ви можете користуватися фунціями:\n/schedule_day\n/new_schedule\n</b>")


@dp.callback_query_handler(lambda c: c.data == 'group_cancel')
async def process_callback_group_cancel(callback_query: types.CallbackQuery):
    """ This function handles the callback when the group name setting is cancel. """
    
    await bot.answer_callback_query(callback_query.id, "Settings group name")
    await bot.send_message(callback_query.message.chat.id, f"<b>Відміна встановлення групи</b>")



"""                                                                                """
"""                Button functions, to confirm schedule, or decline               """

@dp.callback_query_handler(lambda c: c.data == 'schedule_confirm')
async def process_callback_schedule_confirm(callback_query: types.CallbackQuery):
    """ This function handles the callback when the schedule adding is confirm. """
    text = callback_query.message["text"]   

    lines = text.splitlines()  # Split text into lines

    for line in lines:
        if "Ім'я групи" in line:
            group_name = line.split("-")[1].strip()  # Get value after "-"
        elif "день неділі" in line:
            day_of_week = line.split("-")[1].strip()  # Get value after "-"
        elif "Назва предмету" in line:
            subject = line.split("-")[1].strip()
        elif "Початок" in line:
            start_time = line.split("-")[1].strip()  # Get value after "-"
        
  
    num_week = 1
    # Get the updated schedule for the day after adding the subject
    schedule_of_day = scheduleTable.get_subject_by_day_and_time(group_name, day_of_week, start_time, num_week)
    
    await bot.send_message(callback_query.message.chat.id, f"<b>\U00002705 Предмет було успішно добавлено у ваш розклад</b>")
    await bot.answer_callback_query(callback_query.id, "schedule updating confirm!")
    
    scheduleTable.insert_test(group_name, day_of_week, subject, start_time, num_week=1)
    # Update the message with the new schedule day
    callback_query.message.text = f"/schedule_day {callback_query.message.text[30:38]}"
    await callback_query.message.edit_text(text=callback_query.message.text)
    await schedule_day(callback_query.message, day_of_week)

@dp.callback_query_handler(lambda c: c.data == 'schedule_cancel')
async def process_callback_schedule_cancel(callback_query: types.CallbackQuery):
    """ This function handles the callback when the schedule adding is canceled. """

    await bot.answer_callback_query(callback_query.id, "Schedule updating cancel!")
    await bot.send_message(callback_query.message.chat.id, f"<b>Зміни відхилині!</b>")
    


"""      processing user actions, using button data -> confim or decline deletting task     """
"""                                                                                         """

@dp.callback_query_handler(lambda c: c.data == 'taskDellConfirm')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """ This function handles the callback when the task delete is confirmed. It sends a confirmation message and then deletes the task """
    
    await bot.answer_callback_query(callback_query.id, "Delete confirm")
    await bot.send_message(callback_query.message.chat.id, f"<b>Delete confirm</b>")
 
    user_id = callback_query.from_user.id
    student.delete_task(user_id)
  

@dp.callback_query_handler(lambda c: c.data == 'taskDellDecline')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """This function handles the callback when the task delete is declined. It sends a decline message."""
    
    await bot.answer_callback_query(callback_query.id, "Delete decline")
    await bot.send_message(callback_query.message.chat.id, f"<b>Delete decline</b>")


"""      Info about command /new_task        """
@dp.callback_query_handler(lambda c: c.data == 'new_task_help')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """ This function provides information about the /new_task command. It sends a message explaining how to use the command. """
   
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>Після команди: /new_task введіть назву вашого таску.</b>")

"""      Info about command /task_list        """
@dp.callback_query_handler(lambda c: c.data == 'task_info_help')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """ This function provides information about the /task_list command. It sends a message explaining how to use the command. """

    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>Введіть команду /task_list, щоб побачити активні таски</b>")
    print(callback_query.message)
    
   


"""      Info about command /doc        """
@dp.callback_query_handler(lambda c: c.data == 'doc_creating')
async def process_callback_task_delete_accept(callback_query: types.CallbackQuery):
    """  This function provides information about the /doc command. It sends a message explaining how to use the command. """
   
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"<b>Після команди /doc напишіть:\nНазву дисципліни, назву групи, ім'я студента, ім'я вчителя\nЩоб все коректно обробити, напшіть дані через кому</b>")
    print(callback_query.message)

#keyboard_five

"""      Accept words deleting command /word_done        """
@dp.callback_query_handler(lambda c: c.data == 'wordsDeleteAccept')
async def process_callback_words_delete_accept(callback_query: types.CallbackQuery):
    """  This function delete words from DB.  """

    user_id = callback_query.from_user.id
    print(user_id)
    text = callback_query.message["text"].strip().split(":")
    print(text[1])

    
    test = wordDataBase.get_specific_language_words(user_id, text[1].strip())

    if len(test) == 0:
        await bot.send_message(callback_query.message.chat.id, f"<b>Ви вже видалили дані</b>")
        return
    

    wordDataBase.remove_words_by_language(user_id, text[1].strip())

    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(callback_query.message.chat.id, f"✅ Слова були видалені")
    callback_query.from_user.is_bot = True

    await words_list_callback(callback_query)


@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def handle_info_message_iso_in_private_chat(message: types.Message):
    """
    This function handles incoming text messages in a private chat and processes them as ISO commands.

    Args:
        message: The message object containing the received text.

    Result:
        The message is processed as an ISO command.
    """
    if message.chat.type == types.ChatType.PRIVATE and not message.text.startswith('/'):
        await handle_info_command_iso(message)


dp.register_message_handler(voice_message_handler, content_types=types.ContentType.VOICE)
dp.register_message_handler(check_schedule_for_all_groups, commands="start")
dp.register_message_handler(handle_info_message_iso_in_private_chat, content_types=types.ContentType.TEXT)


if __name__ == '__main__':
    # Create an asyncio event loop
    
    loop = asyncio.get_event_loop()
    
    stt_rec = STT()
    # Run the check_schedule coroutine in the event loop
    loop.create_task(check_schedule_for_all_groups())

    # Start the aiogram executor 
    executor.start_polling(dp)



    